<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kotlin基础 | HHR的小世界</title><meta name="author" content="HI-IR"><meta name="copyright" content="HI-IR"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Kotlin基础变量变量的定义123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [&#x3D; &lt;property_initializer&gt;]    [&lt;getter&gt;]    [&lt;setter&gt;]    函数创建函数123权限修饰符 fun 函数名称([函数参数...]): 返回值类型 &#123;    &#x2F;&#x2F;函数体">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin基础">
<meta property="og:url" content="http://example.com/2025/03/05/Kotlin%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="HHR的小世界">
<meta property="og:description" content="Kotlin基础变量变量的定义123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [&#x3D; &lt;property_initializer&gt;]    [&lt;getter&gt;]    [&lt;setter&gt;]    函数创建函数123权限修饰符 fun 函数名称([函数参数...]): 返回值类型 &#123;    &#x2F;&#x2F;函数体">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/tit.png">
<meta property="article:published_time" content="2025-03-05T15:33:30.000Z">
<meta property="article:modified_time" content="2025-03-05T15:35:47.862Z">
<meta property="article:author" content="HI-IR">
<meta property="article:tag" content="安卓学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/tit.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/03/05/Kotlin%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":null,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kotlin基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/tit.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archieves/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/tag.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">HHR的小世界</span></a><a class="nav-page-title" href="/"><span class="site-name">Kotlin基础</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archieves/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Kotlin基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-05T15:33:30.000Z" title="发表于 2025-03-05 23:33:30">2025-03-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-05T15:35:47.862Z" title="更新于 2025-03-05 23:35:47">2025-03-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Kotlin基础"><a href="#Kotlin基础" class="headerlink" title="Kotlin基础"></a>Kotlin基础</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure>



<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 <span class="function"><span class="keyword">fun</span> 函数名称<span class="params">([函数参数...])</span></span>: 返回值类型 &#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="高阶函数与lambda表达式，匿名函数，闭包"><a href="#高阶函数与lambda表达式，匿名函数，闭包" class="headerlink" title="高阶函数与lambda表达式，匿名函数，闭包"></a>高阶函数与lambda表达式，匿名函数，闭包</h3><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><blockquote>
<ul>
<li><p>高阶函数：如果一个函数接收另一个函数作为参数，或者返回值的类型就是一个函数，那么该函数称为高阶函数</p>
</li>
<li><p>函数可以被存储在变量中，可以作为参数传递给其他高阶函数并从中返回，就想使用普通变量一样</p>
<p>类型，例如：以一个String为参数，空返回值的函数的类型：(String) -&gt; Unit</p>
</li>
</ul>
</blockquote>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><blockquote>
<p>匿名函数有类型，匿名函数可以当作变量 赋值给 函数类型变量</p>
<p>函数的类型由传入的参数和返回值类型决定。例如：以一个String为参数，空返回值（Unit）的函数的类型：(String) -&gt; Unit</p>
<p>lambda表达式是给函数变量赋值的一种方式，也可以用 匿名函数（<code>fun</code> 关键字定义）</p>
</blockquote>
<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">val</span> lambdaName: (参数类型) -&gt; 返回类型 = &#123; 参数名: 参数类型 -&gt; 函数体 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>lambda表达式不需要return来返回数据，他会隐式<strong>自动返回函数体最后一行的结果</strong></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量的类型是一个匿名函数(类型：()-&gt;String)</span></span><br><span class="line"><span class="keyword">val</span> func :()-&gt;String</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值一个匿名函数,和具名函数不同，lambda表达式不需要return来返回数据，他会隐式自动返回函数体最后一行的结果</span></span><br><span class="line">func = &#123;</span><br><span class="line">    <span class="keyword">val</span> name= <span class="string">&quot;姓名&quot;</span></span><br><span class="line">    <span class="string">&quot;你好，<span class="subst">$&#123;name&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当lambda有一个参数时，用<code>it</code>代替。当lambda有多个参数时，需要把参数名放在函数定义中</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> func:(String)-&gt;<span class="built_in">Boolean</span> = &#123;name -&gt;<span class="comment">//这个name就是参数名（String）</span></span><br><span class="line">                             </span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>因为 在 Kotlin 的 Lambda 表达式里，<strong><code>return</code> 默认会终止最外层的函数，而不是只返回 Lambda 的值！（非局部返回（non-local return））</strong>，所以在Lambda中没有办法直接使用return语句返回结果</li>
<li>如果你只想让 Lambda 自己返回，而不是终止外层函数，那就需要用<strong>标签返回（label return）</strong></li>
</ul>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>用<code>inline</code>关键字标记的函数</p>
<h3 id="中缀函数"><a href="#中缀函数" class="headerlink" title="中缀函数"></a>中缀函数</h3><p>用<code>infix</code>关键字标记的函数被称为中缀函数，在使用时，可以省略调用的点和括号进行调用，infix函数必须满足以下要求：</p>
<ul>
<li>必须是成员函数。</li>
<li>只能有一个参数。</li>
<li>参数不能有默认值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(string: <span class="type">String</span>)</span></span>: String&#123;</span><br><span class="line">        <span class="keyword">return</span> name+string</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">student test <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注：中缀函数调用的优先级低于算术运算符、类型转换和<code>rangeTo</code>运算符</li>
</ul>
<h2 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h2><h3 id="类的创建，使用"><a href="#类的创建，使用" class="headerlink" title="类的创建，使用"></a>类的创建，使用</h3><p>Kotlin中的类可以添加一个<strong>主构造函数</strong>和一个或多个<strong>次要构造函数</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类的定义 + 主构造函数(主构造函数是类定义的一部分)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">constructor</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> (name: String ,age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name :String = name</span><br><span class="line">    	<span class="keyword">get</span>() &#123;<span class="keyword">return</span> field&#125;</span><br><span class="line">        <span class="keyword">set</span>(value)&#123;field = value&#125;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = age</span><br><span class="line">        <span class="keyword">get</span>() &#123;<span class="keyword">return</span> field&#125;</span><br><span class="line">        <span class="keyword">set</span>(value)&#123;field = value&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不希望这些属性在一开始就有初始值，而是之后某一个时刻去设定初始值，我们也可以为其添加懒加载(lateinit )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">次构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String,<span class="keyword">var</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String):<span class="keyword">this</span>(name,<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主构造函数可以加var或者val，但次构造函数不可</p>
<p>次构造函数需要调用其他构造函数（可以是主构造函数，也可以是次构造函数），但是调用链<strong>最终要调用主构造函数</strong></p>
</blockquote>
<p>因此，主构造函数相比次要（辅助）构造函数：</p>
<ul>
<li><strong>主构造函数：</strong> 可以直接在主构造函数中定义类属性，使用更方便，但是主构造函数只能存在一个，并且无法编写函数体，只有为类属性做初始化赋值的效果。</li>
<li><strong>辅助（次要）构造函数：</strong> 可以存在多个，并且可以自定义函数体，但是无法像主构造函数那样定义类属性，并且当类具有主构造函数时，所有次要构造函数必须直接或间接地调用主构造函数。</li>
</ul>
<h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><p>在对象创建时，我们可能需要做一些初始化工作，我们可以使用初始化代码块来完成</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">constructor</span>(<span class="keyword">var</span> name: String,<span class="keyword">var</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;初始化代价快&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String): <span class="keyword">this</span>(name,<span class="number">18</span>)&#123;</span><br><span class="line">        println(<span class="string">&quot;1 次构造函数&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(age: <span class="built_in">Int</span>):<span class="keyword">this</span>(<span class="string">&quot;小明&quot;</span>)&#123;</span><br><span class="line">        println(<span class="string">&quot;2 次构造函数&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;                                                                                                                                                  </span><br></pre></td></tr></table></figure>

<p><strong>对象初始化过程：</strong></p>
<p>调用辅助构造函数时：通过辅助构造函数调用主构造函数，主构造函数，init代码块，辅助构造函数代码块</p>
<h3 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h3><p>在类里面定义呗，和java没什么不同</p>
<h3 id="运算符重载（我是在学C-吗？）"><a href="#运算符重载（我是在学C-吗？）" class="headerlink" title="运算符重载（我是在学C++吗？）"></a>运算符重载（我是在学C++吗？）</h3><p>Kotlin支持为程序中已知的运算符集提供自定义实现，这些运算符具有固定的符号表示（如<code>+</code>或<code>*</code>）以及对应的优先级，要实现运算符重载，请为相应类型提供具有对应运算符指定名称的成员函数，而当前的类对象，则直接作为对应运算符左边的操作数（类比C++）</p>
<p><strong>operator关键字</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> (<span class="keyword">var</span> name: String ,<span class="keyword">var</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="comment">//比如我们希望两个学生对象相加，得到的结果为名字相加，年龄相加的一个新学生</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(another: <span class="type">Student</span>)</span></span>: Student&#123;</span><br><span class="line">        <span class="keyword">return</span> Student(<span class="keyword">this</span>.name+another.name,<span class="keyword">this</span>.age+another.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常见的一些运算符对应的函数名称"><a href="#常见的一些运算符对应的函数名称" class="headerlink" title="常见的一些运算符对应的函数名称"></a>常见的一些运算符对应的函数名称</h4><table>
<thead>
<tr>
<th>符号(一元运算符)</th>
<th>对应的函数名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>+a</code></td>
<td><code>a.unaryPlus()</code></td>
</tr>
<tr>
<td><code>-a</code></td>
<td><code>a.unaryMinus()</code></td>
</tr>
<tr>
<td><code>!a</code></td>
<td><code>a.not()</code></td>
</tr>
<tr>
<td><code>a--</code></td>
<td><code>a.dec()</code></td>
</tr>
<tr>
<td><code>a++</code></td>
<td><code>a.inc()</code></td>
</tr>
</tbody></table>
<p><code>inc()</code>和<code>dec()</code>函数比较特殊，它们必须返回一个值，执行后应该得到一个新生成的对象，然后变量的值直接引用到这个新的对象</p>
<table>
<thead>
<tr>
<th>符号（二元运算符）</th>
<th>对应的函数名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>a + b</code></td>
<td><code>a.plus(b)</code></td>
</tr>
<tr>
<td><code>a - b</code></td>
<td><code>a.minus(b)</code></td>
</tr>
<tr>
<td><code>a * b</code></td>
<td><code>a.times(b)</code></td>
</tr>
<tr>
<td><code>a / b</code></td>
<td><code>a.div(b)</code></td>
</tr>
<tr>
<td><code>a % b</code></td>
<td><code>a.rem(b)</code></td>
</tr>
<tr>
<td><code>a..b</code></td>
<td><code>a.rangeTo(b)</code></td>
</tr>
<tr>
<td><code>a..&lt;b</code></td>
<td><code>a.rangeUntil(b)</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号(复合赋值运算符)</th>
<th>对应的函数名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>a += b</code></td>
<td><code>a.plusAssign(b)</code></td>
</tr>
<tr>
<td><code>a -= b</code></td>
<td><code>a.minusAssign(b)</code></td>
</tr>
<tr>
<td><code>a *= b</code></td>
<td><code>a.timesAssign(b)</code></td>
</tr>
<tr>
<td><code>a /= b</code></td>
<td><code>a.divAssign(b)</code></td>
</tr>
<tr>
<td><code>a %= b</code></td>
<td><code>a.remAssign(b)</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号(返回Boolean)</th>
<th>对应的函数名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>a in b</code></td>
<td><code>b.contains(a)</code></td>
</tr>
<tr>
<td><code>a !in b</code></td>
<td><code>!b.contains(a)</code></td>
</tr>
</tbody></table>
<p>比较运算符只需要实现一个函数即可：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>对应的函数名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>a &gt; b</code></td>
<td><code>a.compareTo(b) &gt; 0</code></td>
</tr>
<tr>
<td><code>a &lt; b</code></td>
<td><code>a.compareTo(b) &lt; 0</code></td>
</tr>
<tr>
<td><code>a &gt;= b</code></td>
<td><code>a.compareTo(b) &gt;= 0</code></td>
</tr>
<tr>
<td><code>a &lt;= b</code></td>
<td><code>a.compareTo(b) &lt;= 0</code></td>
</tr>
</tbody></table>
<p> 函数调用运算符重载</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>对应的函数名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>a()</code></td>
<td><code>a.invoke()</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>运算符</th>
<th>对应的函数名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>a[i]</code></td>
<td><code>a.get(i)</code></td>
</tr>
</tbody></table>
<h3 id="中缀函数-1"><a href="#中缀函数-1" class="headerlink" title="中缀函数"></a>中缀函数</h3><p>用<code>infix</code>关键字标记的函数被称为中缀函数，在使用时，可以省略调用的点和括号进行调用，infix函数必须满足以下要求：</p>
<ul>
<li>必须是成员函数。</li>
<li>只能有一个参数。</li>
<li>参数不能有默认值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(string: <span class="type">String</span>)</span></span>: String&#123;</span><br><span class="line">        <span class="keyword">return</span> name+string</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">student test <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注：中缀函数调用的优先级低于算术运算符、类型转换和<code>rangeTo</code>运算符</li>
</ul>
<h3 id="空值和-可-空类型"><a href="#空值和-可-空类型" class="headerlink" title="空值和(可)空类型"></a>空值和(可)空类型</h3><p>所有的类型默认都是<strong>非空类型</strong>，非空类型的变量是不允许被赋值为null的</p>
<p>如果我们希望某个变量在初始情况下使用<code>null</code>而不去引用某一个具体对象，该怎么做呢，此时我们需要将变量的类型修改为<strong>可空类型</strong>，只需在类型名称的后面添加一个<code>?</code></p>
<p>在调用的时候用if判断</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student: Student? =<span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (student != <span class="literal">null</span>)&#123;</span><br><span class="line">        student.age</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果不想用if包裹</p>
<blockquote>
<ul>
<li><p>如果我们很明确知道这个可空类型一定不为空可以使用<strong>非空断言操作符（<code>!!</code>）</strong></p>
<p>例如：<code>student!!.age</code>调用</p>
</li>
<li><p>也可以使用<strong>安全调用运算符（<code>?.</code>）</strong>，如果对象为空则返回null</p>
<p>例如：<code>student?.age</code></p>
</li>
<li><p>不过在有些时候，可能我们希望如果变量为null，在使用安全调用运算符时，返回一个我们自定义的结果，而不是null，则可以使用<strong>空合并操作符?：</strong></p>
<p>例如：student?.age ?: “自定义结果”</p>
</li>
</ul>
</blockquote>
<h3 id="空合并操作符"><a href="#空合并操作符" class="headerlink" title="空合并操作符?:"></a>空合并操作符?:</h3><p>?:操作符的意思是，如果左边的求值结果为null，就使用右侧的结果值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">student?.age ?: <span class="string">&quot;自定义结果&quot;</span>  </span><br></pre></td></tr></table></figure>







<h3 id="解构声明"><a href="#解构声明" class="headerlink" title="解构声明"></a>解构声明</h3><blockquote>
<p>允许你将一个对象分解为多个变量</p>
</blockquote>
<p>要让一个类的属性支持解构，我们只需添加约定的函数即可，在Kotlin中，我们可以自定义解构出来的结果，而具体如何获取，需要定义一个<strong>componentN</strong>函数并通过返回值的形式返回解构的结果</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span> = name   <span class="comment">//使用component1表示解构出来的第一个参数</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span> = age    <span class="comment">//使用component2表示解构出来的第二个参数</span></span><br><span class="line">  	<span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> component3...  //以此类推</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">val</span> s1 = Student(<span class="string">&quot;小明&quot;</span>,<span class="number">18</span>)</span><br><span class="line"><span class="keyword">val</span>(name , age) = s1</span><br><span class="line"><span class="comment">//此时name=&quot;小明&quot; 、age=18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="权限控制（和java有些不同）"><a href="#权限控制（和java有些不同）" class="headerlink" title="权限控制（和java有些不同）"></a>权限控制（和java有些不同）</h3><p>在类、对象、接口、构造函数和函数，以及属性上，可以为其添加 <em>可见性修饰符</em> 来控制其可见性</p>
<p><strong>public</strong>、<strong>protected</strong>、<strong>internal</strong>、<strong>private</strong>、</p>
<ol>
<li><code>public</code> : 公开，可见性最大，哪里都可以引用</li>
<li><code>private</code>: 私有，可见性最小</li>
<li><code>protected</code>: 保护，相当于<code>private</code> + 子类可见(不可以用做顶级声明，只能用作类成员)</li>
<li><code>internal</code>: 内部，仅对module可见</li>
</ol>
<h2 id="封装继承多态"><a href="#封装继承多态" class="headerlink" title="封装继承多态"></a>封装继承多态</h2><blockquote>
<ul>
<li>封装，把对象的属性和函数结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。</li>
<li>继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和函数，并根据实际需求扩展出新的行为。</li>
<li>多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的函数</li>
</ul>
</blockquote>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote>
<p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员—–成员私有化</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>在 Kotlin 中，类是默认 <strong>final（终态）</strong> 的，也就是说，除非显式声明为 <code>open</code></li>
<li>单继承</li>
<li>继承时需要调用父类的构造函数，完成对父类属性的初始化（子类必须初始化父类属性），如果父类只有次构造函数，子类必须在自己的次构造函数中使用 <code>super</code> 显式调用父类的构造函数。</li>
<li>先完成父类的构造，再完成之类的构造</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承语法：</span></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">protected</span> <span class="keyword">var</span> name: String, <span class="keyword">protected</span> <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="comment">//调用父类的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArtStudent</span>(name: String, age: <span class="built_in">Int</span>, <span class="keyword">protected</span> <span class="keyword">val</span> school: String) : Student(name, age) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为<code>private</code>，那么子类将无法访问（但是依然是继承了这个属性的）</p>
</blockquote>
<h3 id="方法与属性的重写"><a href="#方法与属性的重写" class="headerlink" title="方法与属性的重写"></a>方法与属性的重写</h3><ol>
<li><p>父类的成员需要用 <code>open</code> 修饰。</p>
</li>
<li><p>子类中用 <code>override</code> 关键字实现重写</p>
</li>
</ol>
<blockquote>
<p>对于这些使用了<code>open</code>关键字的属性（函数、变量等）只要是在初始化函数、构造函数中使用，IDEA都会给出警告</p>
</blockquote>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>向上转型： 直接强制转型就好了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> artStudent: Student = ArtStudent()</span><br></pre></td></tr></table></figure>



<p>向下转型：<strong>as</strong>关键字强转</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(student: <span class="type">Student</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> artStudent: ArtStudent = student <span class="keyword">as</span> ArtStudent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Any类"><a href="#Any类" class="headerlink" title="Any类"></a>Any类</h3><p>Kotlin类层次结构的根。每个Kotlin类都有 Any 作为超类</p>
<h4 id="运算符重载equals"><a href="#运算符重载equals" class="headerlink" title="运算符重载equals"></a>运算符重载equals</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure>

<ul>
<li><em>结果上</em> 相等 (<code>==</code> 等价于 <code>equals()</code>)</li>
<li><em>引用上</em> 相等 (<code>===</code> 判断两个变量是否都是引用的同一个对象)</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>我们设计的类可能仅仅是作为给其他类继承使用的类，而其本身并不需要创建任何实例对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用abstract表示这个是一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> type: String  <span class="comment">//抽象类中可以存在抽象成员属性</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span>   <span class="comment">//抽象类中可以存在抽象函数</span></span><br><span class="line">  	<span class="comment">//注意抽象的属性不能为private，不然子类就没法重写了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个子类继承自抽象类时，必须要<strong>重写</strong>抽象类中定义的抽象属性和抽象函数：</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口一般只代表某些功能的抽象，接口包含了一系列内容的定义，类可以实现这个接口，表示类支持接口代表的功能。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x: String  <span class="comment">//接口中所有属性默认都是abstract的（可省略关键字）</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sleep</span><span class="params">()</span></span>   <span class="comment">//接口中所有函数默认都是abstract的（可省略关键字），也可以带有默认实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">game</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="type">A</span>, <span class="type">B</span> &#123;   <span class="comment">//接口的实现与类的继承一样，直接写到后面，多个接口用逗号隔开</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: String = <span class="string">&quot;测试&quot;</span>   <span class="comment">//跟抽象类一样，接口中的内容是必须要实现的</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sleep</span><span class="params">()</span></span> = println(<span class="string">&quot;管他什么早八不早八的，睡舒服再说&quot;</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">game</span><span class="params">()</span></span> = println(<span class="string">&quot;读大学就该玩游戏玩到爽&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中声明的属性可以是抽象的，也可以为Getter提供默认实现。在接口中声明的属性无法使用<code>field</code>后背字段，因此在接口中声明的Setter无法使用<code>field</code>进行赋值</p>
<h3 id="类的扩展"><a href="#类的扩展" class="headerlink" title="类的扩展"></a>类的扩展</h3><p>为某个类添加一些额外的函数或是属性，我们只需要通过一个被称为<em>扩展</em>的特殊声明来完成</p>
<p>比如我们想为String类型添加一个自定义的操作：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为官方的String类添加一个新的test函数，使其返回自定义内容</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">test</span><span class="params">()</span></span> = <span class="string">&quot;666&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> text = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    println(text.test())  <span class="comment">//就好像String类中真的有这个函数一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="当扩展函数作为参数赋值给变量时"><a href="#当扩展函数作为参数赋值给变量时" class="headerlink" title="当扩展函数作为参数赋值给变量时"></a>当扩展函数作为参数赋值给变量时</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="comment">//因为是对String类型的扩展函数，需要String.前缀</span></span><br><span class="line">    <span class="keyword">val</span> func: String.() -&gt; <span class="built_in">Int</span> = &#123;</span><br><span class="line">        <span class="keyword">this</span>.length   <span class="comment">//跟上面一样，扩展函数中的this依然指的是被扩展的类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;sahda&quot;</span>.func())  <span class="comment">//可以直接对符合类型的对象使用这个函数</span></span><br><span class="line">  	func(<span class="string">&quot;Hello&quot;</span>)  <span class="comment">//如果是直接调用，那么必须要传入对应类型的对象作为首个参数，此时this就指向我们传入的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="Kotlin进阶"><a href="#Kotlin进阶" class="headerlink" title="Kotlin进阶"></a>Kotlin进阶</h1><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型，（只是声明有这个临时数据类型）</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>类，接口，抽象类都支持泛型操作</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">var</span> name: String, <span class="keyword">var</span> value: T)</span><br><span class="line"><span class="comment">//这里的T就是一个待定的类型，同样是这个类具有的，我们称为泛型参数</span></span><br><span class="line"><span class="comment">//T相当于一个临时类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">var</span> score = Score&lt;<span class="built_in">Int</span>&gt;(<span class="string">&quot;小明&quot;</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>如果在编译阶段能够确定泛型的具体类型，也可以不用<Int>，自动推断</li>
<li>泛型类型在类内部使用时，由于无法确定具体类型，也只能当做<code>Any?</code>类去使用</li>
<li>泛型类型在类内部使用时，不能通过这个不确定的类型变量就去直接创建对象</li>
</ul>
</blockquote>
<h4 id="有关泛型的继承问题"><a href="#有关泛型的继承问题" class="headerlink" title="有关泛型的继承问题"></a>有关泛型的继承问题</h4><p>子类在继承时，可以选择将父类的泛型参数给明确为某一类型，或是使用子类定义的泛型参数作为父类泛型参数的实参使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">T</span>&gt;()&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>:T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类在继承时，可以选择将父类的泛型参数给明确为某一类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>():A&lt;String&gt;()&#123;<span class="comment">//子类直接明确为String类型</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>: String =<span class="string">&quot;Hello&quot;</span><span class="comment">//明确后所有用到泛型的地方都要变成具体类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//或是子类也是泛型,子类定义的泛型参数作为父类泛型参数的实参使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;<span class="type">D</span>&gt;():A&lt;D&gt;()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>: D &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; test(t: T): T = t</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test</span><span class="params">(func: (<span class="type">Int</span>) -&gt; <span class="type">T</span>)</span></span> : T&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test</span><span class="params">(T.()</span></span> -&gt; <span class="built_in">Unit</span>)&#123;	<span class="comment">////甚至还可以是T类型的扩展函数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="官方高阶扩展函数"><a href="#官方高阶扩展函数" class="headerlink" title="官方高阶扩展函数"></a>官方高阶扩展函数</h3><h4 id="Any-apply-函数"><a href="#Any-apply-函数" class="headerlink" title="Any.apply()函数"></a>Any.apply()函数</h4><p>它可以让你在一个对象上执行一系列操作，同时保持代码的简洁性和可读性。它常用于对象的初始化和配置，以及链式调用</p>
<ul>
<li><code>apply()</code> 函数最终会返回调用它的对象本身。</li>
</ul>
<p>在匿名函数中处理<strong>调用apply()的对象</strong>，并返回对象本身</p>
<h4 id="Any-let-函数"><a href="#Any-let-函数" class="headerlink" title="Any.let()函数"></a>Any.let()函数</h4><p><code>let</code>：用于执行一个lambda表达式并将得到一个<strong>新的类型</strong>值并作为结果返回</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对当前对象进行操作，得到一个新的类型值并作为结果返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">   	...</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)  <span class="comment">//调用我们传入的函数，并将结果作为let返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Any-also-函数"><a href="#Any-also-函数" class="headerlink" title="Any.also()函数"></a>Any.also()函数</h4><p><code>also</code>：用于执行一个lambda表达式并返回对象本身，跟apply功能一致像，但是采用的是<code>it</code>参数形式传递给Lambda当前对象，而apply是采用this(扩展函数)的方式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对当前对象进行操作，并返回当前对象本身</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    ...</span><br><span class="line">    block(<span class="keyword">this</span>)   <span class="comment">//调用我们传入的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>   <span class="comment">//返回当前T类型对象本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Any-run-函数"><a href="#Any-run-函数" class="headerlink" title="Any.run()函数"></a>Any.run()函数</h4><p>用于执行一个lambda表达式并将得到的结果作为返回值返回，它跟let一样，使用this传递当前对象，可以看到接受的参数是一个扩展函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Any.apply()和Any.run()底层是靠	传入的函数是<strong>扩展函数</strong>实现的</p>
<p>Any.also() 和 Any.let()底层是考 	传入的函数是<strong>普通匿名</strong>函数实现的</p>
<p>Any.apply()与Any.also()，和Any.run()与 Any.let()实现的功能相近，只是底层不一样</p>
<h4 id="Any-takeIf-函数与Any-takeUnless-函数"><a href="#Any-takeIf-函数与Any-takeUnless-函数" class="headerlink" title="Any.takeIf()函数与Any.takeUnless()函数"></a>Any.takeIf()函数与Any.takeUnless()函数</h4><ul>
<li>takeIf()函数：传入一个判断表达式，如果表达式为true则返回调用者，为false则返回null</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeIf</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>takeUnless()函数：与takeIf()相反</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeIf</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (!predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="协变、逆变、抗变"><a href="#协变、逆变、抗变" class="headerlink" title="*协变、逆变、抗变"></a>*协变、逆变、抗变</h3><p>泛型类型参数的默认情况下，泛型参数是 <strong>不变的（Invariant）</strong>。这意味着如果 <code>B</code> 是 <code>A</code> 的子类型，那么 <code>Box&lt;B&gt;</code> 并不是 <code>Box&lt;A&gt;</code> 的子类型</p>
<p>如果 <code>B</code> 是 <code>A</code> 的子类型，正常情况下只能子类转换为父类，泛型类型<code>Test&lt;T&gt;</code>存在以下几种形变：</p>
<ul>
<li>协变 (Covariance)：因为B是A的子类，所以<code>Test&lt;B&gt;</code>同样是<code>Test&lt;A&gt;</code>的子类，可以直接转换</li>
<li>逆变(Contravariance)：跟上面相反，<code>Test&lt;A&gt;</code>可以直接转换为<code>Test&lt;B&gt;</code>，前者是后者的子类</li>
<li>抗变 (Invariant)：<code>Test&lt;B&gt;</code>跟<code>Test&lt;A&gt;</code>没半毛钱关系，无法互相转换</li>
</ul>
<p>Kotlin中泛型类型参数默认是抗变的</p>
<p>但是实际上我们需要的可能是协变或是逆变，为了处理这种情况，Kotlin提供了两个关键字供我们使用：</p>
<ul>
<li><code>out</code> 关键字用于标记一个类型参数作为协变，可以实现子类到父类的转换。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> test1: Test&lt;<span class="built_in">Int</span>&gt; = Test(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> test2: Test&lt;<span class="keyword">out</span> Number&gt; = test1<span class="comment">//协变</span></span><br><span class="line"><span class="comment">//这里的out Number 相当于java中的 ? extends Number</span></span><br></pre></td></tr></table></figure>

<p>​		out Number 代表 Number所有的子类</p>
<p>​		协变类型在使用时会变成上界，因为无论子类是什么，都是继承自上界类型的，所以类型默认为上界</p>
<ul>
<li><code>in</code> 关键字用于标记一个类型参数作为逆变，可以实现父类到子类的转换。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> test: Test&lt;Any&gt; = Test(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> test2: Test&lt;<span class="keyword">in</span> <span class="built_in">Int</span>&gt; = test</span><br></pre></td></tr></table></figure>

<p>​		in umber 代表Number所有的父类</p>
<p>​		逆变类型在使用时由于没有上界，具体使用哪个父类也不清楚，所以只能是Any?类型了</p>
<blockquote>
<p>注意：因为协变后赋值属性会导致BUG，所以Kotlin对于out或in的类型进行了限制</p>
<p>因此，对于in和out来说，协变和逆变的属性将其限制为了生产者和消费者：</p>
<ul>
<li>使用<code>out</code>修饰的泛型不能用作函数的参数，对应类型的成员变量setter也会被限制，只能当做一个生产者（仅用于输出）使用。</li>
<li>使用<code>in</code>修饰的泛型不能用作函数的返回值，对应类型的成员变量getter也会被限制，只能当做一个消费者（仅用于输入）使用。</li>
</ul>
</blockquote>
<h3 id="通配符（-）"><a href="#通配符（-）" class="headerlink" title="通配符（*）"></a>通配符（*）</h3><p>在有些时候，我们可能并不在乎到底使用哪一个类型，我们希望一个变量可以接受任意类型的结果，而不是去定义某一个特定的上界或下界。在Kotlin泛型中，星号（<code>*</code>）可以代表任意类型，由于不确定具体类型，使用时只能是Any?类型</p>
<h3 id="泛型界限"><a href="#泛型界限" class="headerlink" title="*泛型界限"></a>*泛型界限</h3><h4 id="定义上界"><a href="#定义上界" class="headerlink" title="定义上界"></a>定义上界</h4><ul>
<li>单个上界</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设定类型参数上界，必须是Number或是Number的子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>&lt;<span class="type">T : Number</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> name: String, <span class="keyword">val</span> value: T)</span><br></pre></td></tr></table></figure>

<p>使用类似于继承的语法来完成类型的上界限制，定义后，使用的时候具体类型只能是我们指定的上界类型或其子类</p>
<p>默认不指定时，上界默认为<code>Any?</code></p>
<ul>
<li>多个上界（比如必须同时是某两个类型的子类（或接口实现））</li>
</ul>
<p>使用<code>where</code>关键字</p>
<p>例如：需要同时是Number的子类，同时要实现Comparable接口</p>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="*类型擦除"></a>*类型擦除</h3><p>泛型的类型检查仅仅只存在于编译阶段，在源代码编译之后，实际上并不会保留任何关于泛型的内容，这就是<strong>泛型擦除</strong></p>
<p>例如：擦除前</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">data</span>: T) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(t: <span class="type">T</span>)</span></span> : T &#123;</span><br><span class="line">        <span class="keyword">val</span> tmp = <span class="keyword">data</span></span><br><span class="line">        <span class="keyword">data</span> = t</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>擦除后(泛型类型全变成了Any?)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>(<span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">data</span>: Any?)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(t: <span class="type">Any</span>?)</span></span>: Any?&#123;</span><br><span class="line">        <span class="keyword">val</span> temp = <span class="keyword">data</span></span><br><span class="line">        <span class="keyword">data</span> = t</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>如果存在上界，那么擦除后会是上界的类型</p>
</blockquote>
<p>由于运行时不存在泛型的概念，因此，很多操作都是不允许的，比如类型判断</p>
<h4 id="内联泛型函数的类型擦除"><a href="#内联泛型函数的类型擦除" class="headerlink" title="内联泛型函数的类型擦除"></a>内联泛型函数的类型擦除</h4><p>内联函数，泛型擦除的处理会有一些不同。内联函数的代码是在编译时期直接插入到调用处的，在编译之后具体类型必须要存在，否则会出现问题（因为类型可以明确）因此其泛型参数的具体类型信息是可用的</p>
<p><strong>类型信息在调用处保留</strong></p>
<p><strong>使用关键字<code>reified</code>可具化类型参数,进行类型检查和类型转换</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加reified关键字具化类型参数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">isType</span><span class="params">(value: <span class="type">Any</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value <span class="keyword">is</span> T  <span class="comment">//这样就可以在函数里面使用这个类型了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(isType&lt;String&gt;(<span class="string">&quot;666&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ol>
<li>使用官方预设函数（<code>arrayOf()</code>、<code>arrayOfNulls()</code>、<code>emptyArray()</code>）</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arra: Array&lt;<span class="built_in">Int</span>&gt; = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用类<code>Array</code>构造函数创建。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * size: 数组的大小</span></span><br><span class="line"><span class="comment"> * init: (Int) -&gt; T: 初始化操作，这个操作会根据数组大小，循环调用传入的函数size次，并且将对应的下标作为参数，我们需要在函数中返回当前数组元素类型的结果，这样就会自动填充到数组的对应位置上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">constructor</span>(size: <span class="built_in">Int</span>, <span class="keyword">init</span>: (<span class="built_in">Int</span>) -&gt; T)</span><br></pre></td></tr></table></figure>



<p>Array类的代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">//构造函数，包括数组大小、元素初始化函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">constructor</span>(size: <span class="built_in">Int</span>, <span class="keyword">init</span>: (<span class="built_in">Int</span>) -&gt; T)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载[]运算符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前数组大小（可以看到是val类型的，一旦确定不可修改）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代运算重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 数组在创建完成之后，数组容量和元素类型是固定不变的，后续无法进行修改。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array: Array&lt;<span class="built_in">Int</span>&gt; = arrayof(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(element <span class="keyword">in</span> array)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取到对应索引</span></span><br><span class="line"><span class="keyword">for</span>(index <span class="keyword">in</span> array.indices)&#123;</span><br><span class="line">    println(array[index])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时遍历索引和元素本身，也可以使用withIndex函数</span></span><br><span class="line"><span class="keyword">for</span> ((index,element) <span class="keyword">in</span> array.withIndex())&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用Lambda表达式形式</span></span><br><span class="line"><span class="comment">//Lambda遍历索引,和元素</span></span><br><span class="line">array.forEachIndexed &#123; index, i -&gt;println(<span class="string">&quot;元素<span class="variable">$i</span> ,位置<span class="variable">$index</span>&quot;</span>)&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Lambda遍历元素</span></span><br><span class="line">array.forEach &#123; println(<span class="string">&quot;元素值:<span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;out T&gt;</span>.<span class="title">joinToString</span><span class="params">(separator: <span class="type">CharSequence</span> = <span class="string">&quot;, &quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                         , prefix: <span class="type">CharSequence</span> = <span class="string">&quot;&quot;</span>, postfix: <span class="type">CharSequence</span> = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                         , limit: <span class="type">Int</span> = <span class="number">-1</span>, truncated: <span class="type">CharSequence</span> = <span class="string">&quot;...&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                         , transform: ((<span class="type">T</span>) -&gt; <span class="type">CharSequence</span>)? = <span class="literal">null</span>)</span></span></span><br><span class="line">: String &#123;</span><br><span class="line">    <span class="keyword">return</span> joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>separator</code>: 分隔符</p>
<p><code>prefix</code>: 前缀</p>
<p><code>postfix</code>: 后缀</p>
<p><code>limit</code>: 显示几个元素</p>
<p><code>truncated</code>: 当元素数量超过 <code>limit</code> 时，用于表示截断部分的字符串</p>
<p><code>transform</code>一个可选的转换函数，用于将数组中的每个元素 <code>T</code> 转换为 <code>CharSequence</code> 类型</p>
<h4 id="比较两个数组"><a href="#比较两个数组" class="headerlink" title="比较两个数组"></a>比较两个数组</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从内容上比较2个函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">inline</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;out T&gt;</span>?.<span class="title">contentEquals</span><span class="params">(other: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;?)</span></span>: <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure>



<h4 id="拷贝数组"><a href="#拷贝数组" class="headerlink" title="拷贝数组"></a>拷贝数组</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;T&gt;</span>.<span class="title">copyOf</span><span class="params">()</span></span>: Array&lt;T&gt;<span class="comment">//完整拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;T&gt;</span>.<span class="title">copyOf</span><span class="params">(newSize: <span class="type">Int</span>)</span></span>: Array&lt;T?&gt;<span class="comment">//新数组的长度，扩容则多的填充null </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;T&gt;</span>.<span class="title">copyOfRange</span><span class="params">(fromIndex: <span class="type">Int</span>, toIndex: <span class="type">Int</span>)</span></span>: Array&lt;T&gt;<span class="comment">//拷贝范围的数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;T&gt;</span>.<span class="title">sliceArray</span><span class="params">(indices: <span class="type">IntRange</span>)</span></span>: Array&lt;T&gt;<span class="comment">///拷贝范围的数组</span></span><br></pre></td></tr></table></figure>



<h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array&lt;<span class="keyword">out</span> T&gt;.contains(element: T): <span class="built_in">Boolean</span><span class="comment">//查询数组是否包含element</span></span><br><span class="line"></span><br><span class="line">element <span class="keyword">in</span> array<span class="comment">//就相当于上面</span></span><br><span class="line"></span><br><span class="line">Array&lt;<span class="keyword">out</span> T&gt;.indexOf(element: T): <span class="built_in">Int</span><span class="comment">//返回索引</span></span><br><span class="line">Array&lt;<span class="keyword">out</span> T&gt;.binarySearch(element: T, fromIndex: <span class="built_in">Int</span> = <span class="number">0</span>, toIndex: <span class="built_in">Int</span> = size)<span class="comment">//二分搜索（必须是有序的）</span></span><br></pre></td></tr></table></figure>



<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; Array<span class="type">&lt;out T&gt;</span>.<span class="title">sort</span><span class="params">()</span></span>: <span class="built_in">Unit</span><span class="comment">//默认升序</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; Array<span class="type">&lt;out T&gt;</span>.<span class="title">sortDescending</span><span class="params">()</span></span>: <span class="built_in">Unit</span><span class="comment">//降序</span></span><br></pre></td></tr></table></figure>

<p>如果要用sort函数则首先类型需要实现Comparable接口</p>
<p><em>使用当前对象this和给定对象other进行比较，如果返回小于0的数，说明当前对象应该排在前面，反之排后面，返回0表示同样的级别</em></p>
<h3 id="可变长度参数，扩展运算符"><a href="#可变长度参数，扩展运算符" class="headerlink" title="可变长度参数，扩展运算符"></a>可变长度参数，扩展运算符</h3><p>关键字：<code>vararg</code></p>
<blockquote>
<ul>
<li>可变长度参数一般放在后面（fun test(a: String , vararg str: String)）</li>
<li>但是需要注意的事，可变长参数在函数的形参列表里面只能存在一个</li>
</ul>
</blockquote>
<p>在函数内部，可变长度参数为一个支持协变的数组</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(a:<span class="type">String</span>,<span class="keyword">vararg</span> str: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> array: Array&lt;<span class="keyword">out</span> String&gt; = str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>把数组作为参数给到一个可变长参数中,<strong>扩展运算符</strong>（<code>*</code>）此运算符将数组的每个元素作为单个参数传递</li>
</ul>
<h3 id="原生类型数组"><a href="#原生类型数组" class="headerlink" title="原生类型数组"></a>原生类型数组</h3><p><code>Array&lt;Int&gt;</code>、<code>Array&lt;Double&gt;</code>、<code>Array&lt;Char&gt;</code>等等，这些包含基本类型的数组往往在编译时可以得到优化（比如JVM平台会直接编译为基本类型数组，如<code>int[]</code>、<code>double[]</code>等，可以免去装箱拆箱开销）</p>
<table>
<thead>
<tr>
<th>原生类型数组</th>
<th>相当于Java</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean-array/"><code>BooleanArray</code></a></td>
<td><code>boolean[]</code></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/"><code>ByteArray</code></a></td>
<td><code>byte[]</code></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char-array/"><code>CharArray</code></a></td>
<td><code>char[]</code></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/"><code>DoubleArray</code></a></td>
<td><code>double[]</code></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float-array/"><code>FloatArray</code></a></td>
<td><code>float[]</code></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int-array/"><code>IntArray</code></a></td>
<td><code>int[]</code></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/"><code>LongArray</code></a></td>
<td><code>long[]</code></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short-array/"><code>ShortArray</code></a></td>
<td><code>short[]</code></td>
</tr>
</tbody></table>
<ul>
<li>创建原生类型数组：1. 构造函数   2. intArrayOf()</li>
</ul>
<blockquote>
<p>如果是基本数据类型的可变长度参数，则在函数中参数默认是原生类型数组</p>
</blockquote>
<h4 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="keyword">var</span> array = arrayOf(intArrayOf(<span class="number">1</span>, <span class="number">2</span>), intArrayOf(<span class="number">3</span>, <span class="number">4</span>), intArrayOf(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组构造函数法</span></span><br><span class="line"><span class="keyword">var</span> array = Array(<span class="number">3</span>, &#123; Array(<span class="number">2</span>) &#123; <span class="number">0</span> &#125; &#125;)</span><br><span class="line"><span class="comment">////&#123;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//更高维度同理</span></span><br></pre></td></tr></table></figure>



<p>多层比较可以用：<code>contentDeepEquals()</code></p>
<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p>实现接口Collection</p>
<p><strong>List：</strong>  有序的集合，通过索引访问元素，可以包含重复元素</p>
<p><strong>Set：</strong>  不包含重复元素的集合，它更像是数学中的集合，一般情况下不维护元素顺序</p>
<p><strong>Map：</strong>  是一组键值对，其中每一个键不可重复存在，每个键都映射到恰好一个值（值可以重复存在）</p>
<h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><h4 id="可变List集合MutableList"><a href="#可变List集合MutableList" class="headerlink" title="可变List集合MutableList"></a>可变List集合MutableList</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list: MutableList&lt;String&gt; = mutableListOf(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span> , <span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span> )</span><br></pre></td></tr></table></figure>

<h4 id="不可变集合List"><a href="#不可变集合List" class="headerlink" title="不可变集合List"></a>不可变集合List</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list: List&lt;String&gt; = listOf(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span> , <span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span> )</span><br></pre></td></tr></table></figure>



<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>它不允许存在重复元素，通常情况下是无序的，如果非要访问第N个元素，可以用迭代器来访问</p>
<h4 id="可变Set集合-MutableSet"><a href="#可变Set集合-MutableSet" class="headerlink" title="可变Set集合 MutableSet"></a>可变Set集合 MutableSet</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">mutableSetOf</span><span class="params">(<span class="keyword">vararg</span> elements: <span class="type">T</span>)</span></span>: MutableSet&lt;T&gt; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>底层是 LinkedHashSet</p>
</blockquote>
<h4 id="不可变Set集合-Set"><a href="#不可变Set集合-Set" class="headerlink" title="不可变Set集合 Set"></a>不可变Set集合 Set</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">setOf</span><span class="params">()</span></span>: Set&lt;T&gt;</span><br></pre></td></tr></table></figure>



<h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set1 = mutableSetOf(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> set2 = mutableSetOf(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集(和 + 运算效果一样)</span></span><br><span class="line">println(set1 union  set2)<span class="comment">//A B C D</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求交集</span></span><br><span class="line">println((set1 intersect set2)) <span class="comment">//B C</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求差集(和 - 运算效果一样)</span></span><br><span class="line">println((set1 subtract set2))  <span class="comment">// A</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>集合相关操作也可以应用于List集合，但是计算得到的结果始终是Set集合</p>
</blockquote>
<h4 id="其他用于创建的预设函数"><a href="#其他用于创建的预设函数" class="headerlink" title="其他用于创建的预设函数"></a>其他用于创建的预设函数</h4><p>HashSet</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = hashSetOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;DDD&quot;</span>, <span class="string">&quot;BBB&quot;</span>)   <span class="comment">//创一个不重复且无序的Set集合</span></span><br></pre></td></tr></table></figure>



<p>LinkedSet</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = linkedSetOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;DDD&quot;</span>, <span class="string">&quot;BBB&quot;</span>)  <span class="comment">//跟mutableSetOf一样得到一个不重复且有序的Set集合</span></span><br></pre></td></tr></table></figure>



<p>元素自动排序的Set集合，可自定义排序规则，SortedSet</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortedSet = sortedSetOf(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>





<h4 id="HashSet判断元素是否相同的过程"><a href="#HashSet判断元素是否相同的过程" class="headerlink" title="HashSet判断元素是否相同的过程"></a>HashSet判断元素是否相同的过程</h4><ol>
<li>计算HashCode：调用对象的<code>hashCode()</code>函数</li>
<li>比较HasCode：如果俩元素的HashCode相同，则计算机认为这是2个不同的元素；如果相同则进行步骤3</li>
<li>调用<code>equals()</code>函数：若两个元素的哈希码相同，这可能是不同元素出现了哈希冲突，所以此时计算机会调用对象的<code>equals()</code>函数进行比较，只有当<code>equals()</code>函数返回为true时，计算机认为这是同一个元素</li>
</ol>
<blockquote>
<ol>
<li>重写 <code>equals()</code> 方法时，必须同时重写 <code>hashCode()</code> 方法，以保证两个相等的对象具有相同的哈希码，这是 对象相等性的基本要求</li>
<li>如果没有重写<code>equals()</code>方法和<code>hashCode()</code>函数，计算机会调用Any类的默认实现—比较对象的引用&#x3D;&#x3D;&#x3D;</li>
</ol>
</blockquote>
<h4 id="重写equlas-的同时，必须重写hashCode"><a href="#重写equlas-的同时，必须重写hashCode" class="headerlink" title="重写equlas()的同时，必须重写hashCode()"></a>重写equlas()的同时，必须重写hashCode()</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算并返回对象的哈希值，哈希函数的计算结果需要满足以下标准:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * * 标准1: 对同一个对象调用此函数时，应该始终返回同一个哈希值，除非重写过类的equals函数，修改过比较方式</span></span><br><span class="line"><span class="comment"> * * 标准2: 如果两个对象使用equals函数判断的结果为相同，那么它们计算得到的哈希值也应该相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span></span><br></pre></td></tr></table></figure>



<p><code>hashCode()</code>默认返回对象在内存中存放的地址，以int类型表示</p>
<h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><h4 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt; = Pair(<span class="keyword">this</span>, that)</span><br></pre></td></tr></table></figure>



<p>例如:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pair: Pair&lt;<span class="built_in">Int</span>,String&gt; = <span class="number">100</span> to <span class="string">&quot;小红&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建Map"><a href="#创建Map" class="headerlink" title="创建Map"></a>创建Map</h4><h5 id="可变Map集合-MutableMap"><a href="#可变Map集合-MutableMap" class="headerlink" title="可变Map集合(MutableMap)"></a>可变Map集合(MutableMap)</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> <span class="title">mutableMapOf</span><span class="params">(<span class="keyword">vararg</span> pairs: <span class="type">Pair</span>&lt;<span class="type">K</span>, V&gt;)</span></span>: MutableMap&lt;K, V&gt; </span><br></pre></td></tr></table></figure>



<h5 id="不可变Map集合-Map"><a href="#不可变Map集合-Map" class="headerlink" title="不可变Map集合(Map)"></a>不可变Map集合(Map)</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> <span class="title">mapOf</span><span class="params">(<span class="keyword">vararg</span> pairs: <span class="type">Pair</span>&lt;<span class="type">K</span>, V&gt;)</span></span>: Map&lt;K, V&gt;</span><br></pre></td></tr></table></figure>



<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与该键关联的前一个值，或 null 如果key不在map上</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(key: <span class="type">K</span>, value: <span class="type">V</span>)</span></span>: V?</span><br><span class="line"></span><br><span class="line">map[key: K] = Value: V</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>其他花式添加</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newMap = map + (<span class="number">10004</span> to Student(<span class="string">&quot;小强&quot;</span>, <span class="number">18</span>))   <span class="comment">//添加新的键值对并生成一个新的Map</span></span><br><span class="line">map += (<span class="number">10004</span> to Student(<span class="string">&quot;小强&quot;</span>, <span class="number">18</span>))  <span class="comment">//直接添加键值对到当前Map里面</span></span><br><span class="line">map += mapOf(<span class="number">10004</span> to Student(<span class="string">&quot;小强&quot;</span>, <span class="number">18</span>))  <span class="comment">//或者添加其他Map到此Map中</span></span><br><span class="line">map.putAll(mapOf(<span class="number">10004</span> to Student(<span class="string">&quot;小强&quot;</span>, <span class="number">18</span>)))   <span class="comment">//添加其他Map到此Map中</span></span><br><span class="line">map.putAll(setOf(<span class="number">10004</span> to Student(<span class="string">&quot;小强&quot;</span>, <span class="number">18</span>)))   <span class="comment">//键值对集合也可以的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意一个Key只能对应一个Value，重复赋值会被覆盖</li>
</ul>
<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从此映射中删除指定的键及其对应的值。</span></span><br><span class="line"><span class="comment">//返回:与该键关联的前一个值，或 null 如果key不在Map上。</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(key: <span class="type">K</span>)</span></span>: V?</span><br><span class="line"></span><br><span class="line"><span class="comment">//仅当指定键映射到指定值时，才删除指定键的项。</span></span><br><span class="line"><span class="comment">//返回:如果条目被删除，则为True</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(key: <span class="type">K</span>, value: <span class="type">V</span>)</span></span>: <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>其他花式移除</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map -= <span class="number">10001</span>   <span class="comment">//等价于 map.remove(10001)</span></span><br><span class="line">map -= listOf(<span class="number">10001</span>, <span class="number">10002</span>)   <span class="comment">//批量移除</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据Value删除键值对</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.values.remove(value: V)</span><br><span class="line"><span class="comment">//通过这种方式移除也只会移除按顺序下来的第一个</span></span><br></pre></td></tr></table></figure>





<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><p>同增</p>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>使用<code>[]</code>运算符通过Key查找Value</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">K</span>)</span></span>: V?</span><br><span class="line"></span><br><span class="line">map.getOrDefault(key: K, defaultValue: V)<span class="comment">//使用getOrDefault在没有结果时返回给定的默认值</span></span><br><span class="line">map.getOrElse(key: K, defaultValue: () -&gt; V)<span class="comment">//跟上面一样，只不过是使用函数式返回默认值</span></span><br><span class="line">map.getOrPut(key: K, defaultValue: V)<span class="comment">//在没有返回值的时候把默认值给加到Map里面去,并返回</span></span><br></pre></td></tr></table></figure>



<p>例如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = mutableMapOf(</span><br><span class="line">        <span class="number">1</span> to Student(<span class="string">&quot;小红&quot;</span>, <span class="number">18</span>),</span><br><span class="line">        <span class="number">2</span> to Student(<span class="string">&quot;小明&quot;</span>,<span class="number">12</span>),</span><br><span class="line">        <span class="number">3</span> to Student(<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">var</span> student: Student? = map[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>注意：得到的结果是一个可空的类型—–&gt;当Map中不存在指定的Key时，会直接得到null作为结果</li>
</ul>
</blockquote>
<ul>
<li>查询是否存在</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询是否包含Key</span></span><br><span class="line">map.contains(key: K)</span><br><span class="line">map.containsKey()</span><br><span class="line">key <span class="keyword">in</span> map</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是包含指定Value</span></span><br><span class="line">map.containsValue(value: V)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：只能通过Key去访问Value，而不能通过Value去访问Key，映射关系是单向的</p>
</li>
<li><p>获取keys，values</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.keys</span><br><span class="line">map.values</span><br></pre></td></tr></table></figure>





<h4 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach &#123; k, v -&gt;</span><br><span class="line">    println(<span class="string">&quot;键:<span class="variable">$k</span>,值<span class="variable">$v</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>接口：Iterable</p>
<p>生成迭代器函数：public operator fun iterator(): Iterator<T></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">//获取下一个待遍历元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果还有元素没有遍历，那么返回true否则返回false，而这个函数也是运算符重载函数正好对应着 for in 操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于指针</p>
<blockquote>
<ul>
<li>初始时：</li>
</ul>
<p>​		|	A	|	B	|	C	|</p>
<p>​	↑</p>
<ul>
<li>调用next()：指针往后移动，并返回当前所指对象。直到完成每一个元素的遍历</li>
</ul>
<p>​		|	A	|	B	|	C	|</p>
<p>​			↑</p>
</blockquote>
<p>集合类的实现方案有很多，可能是链式存储，也有可能是数组存储，不同的实现有着不同的遍历方式，而迭代器则可以将多种多样不同的集合类遍历方式进行统一，只需要各个集合类根据自己的情况进行对应实现就行了</p>
<p>同一了集合的遍历操作</p>
<h4 id="遍历数组，集合"><a href="#遍历数组，集合" class="headerlink" title="遍历数组，集合"></a>遍历数组，集合</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    println(iterator.next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<ul>
<li>注意，迭代器的使用是一次性的，用了之后就不能用了，如果需要再次进行遍历操作，那么需要重新生成一个迭代器对象。</li>
</ul>
</blockquote>
<h4 id="实现Iterable接口"><a href="#实现Iterable接口" class="headerlink" title="实现Iterable接口"></a>实现Iterable接口</h4><p>这个接口实不实现其实都无所谓  	</p>
<p>主要是运算符重载函数iterator是必须要的，否则不支持</p>
<p><code>operator fun iterator()</code>函数重载的运算符就是<code>for..in</code>，所以只要实现了<code>iterator()</code>就可以进行for..in</p>
<p>for in 最终都会编译成while操作</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>)   <span class="comment">//编译前</span></span><br><span class="line"><span class="keyword">for</span> (s <span class="keyword">in</span> list) &#123;</span><br><span class="line">    list.add(<span class="string">&quot;DDD&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>)   <span class="comment">//编译后</span></span><br><span class="line"><span class="keyword">val</span> iterator: Iterator&lt;String&gt; = list.iterator()</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">val</span> next = iterator.next()</span><br><span class="line">    println(next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> iterator: ListIterator&lt;String&gt; = list.listIterator()   <span class="comment">//使用listIterator函数来获取ListIterator</span></span><br><span class="line">println(iterator.next())  <span class="comment">//不仅可以正着迭代</span></span><br><span class="line">println(iterator.nextIndex())   <span class="comment">//还可以直接告诉你下一个迭代的是List的第几个元素</span></span><br><span class="line">println(iterator.previous())   <span class="comment">//还能反着来</span></span><br></pre></td></tr></table></figure>



<h4 id="MutableIterator"><a href="#MutableIterator" class="headerlink" title="MutableIterator"></a>MutableIterator</h4><p>在JVM环境下，Kotlin默认不支持在迭代时修改集合里面的内容，无论是插入新的元素还是移除元素，都会触发并发修改异常。</p>
<p>为解决这个问题，Kotlin为所有的MutableCollection（所有非只读集合类）提供了一个特殊的用于生成MutableIterator的函数，只要我们使用的不是只读的集合类，都可以获得这个特殊的迭代器，它支持在遍历时对元素进行<strong>删除</strong> (不能插入)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutableiterator.remove()   <span class="comment">//删除当前迭代器已经遍历的最后一个元素</span></span><br></pre></td></tr></table></figure>



<h3 id="集合与数组的扩展操作"><a href="#集合与数组的扩展操作" class="headerlink" title="集合与数组的扩展操作"></a>集合与数组的扩展操作</h3><h4 id="数组to集合"><a href="#数组to集合" class="headerlink" title="数组to集合"></a>数组to集合</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.toList()</span><br><span class="line">array.toMutableList()</span><br><span class="line">array.toSet()</span><br></pre></td></tr></table></figure>



<h4 id="映射map"><a href="#映射map" class="headerlink" title="映射map"></a>映射map</h4><p>注意这里说的map跟我们前面说的集合Map是两个概念</p>
<p>集合（如 <code>List</code>、<code>Set</code>）,序列 Sequence调用 <code>map</code> 函数时，会遍历集合中的每个元素，将其传入给定的转换函数进行处理，然后把处理结果收集到一个新的集合中返回。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带索引</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">mapIndexed</span><span class="params">(transform: (<span class="type">index</span>: <span class="type">Int</span>, <span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: List&lt;R&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(transform: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: List&lt;R&gt; </span><br></pre></td></tr></table></figure>



<p>对于Map类型，我们还可以单独对所有Key或是Value进行操作：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbersMap = mapOf(<span class="string">&quot;key1&quot;</span> to <span class="number">1</span>, <span class="string">&quot;key2&quot;</span> to <span class="number">2</span>, <span class="string">&quot;key3&quot;</span> to <span class="number">3</span>)</span><br><span class="line">numbersMap.mapKeys &#123;  &#125;  <span class="comment">//对所有的Key进行Map操作</span></span><br><span class="line">numbersMap.mapValues &#123; it.value + it.key.length &#125;</span><br></pre></td></tr></table></figure>



<h4 id="压缩操作"><a href="#压缩操作" class="headerlink" title="压缩操作"></a>压缩操作</h4><p>它可以将当前集合元素和另一个集合中具有<strong>相同索引</strong>的元素组合起来，生成一个装满Pair的列表</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = listOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> pairs: List&lt;Pair&lt;<span class="built_in">Int</span>, String&gt;&gt; = list1.zip(list2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用压缩操作我们可以快速将两个List集合揉成一个Map集合</span></span><br><span class="line"><span class="keyword">val</span> map = mutableMapOf&lt;<span class="built_in">Int</span>, String&gt;()</span><br><span class="line">map.putAll(list1.zip(list2))</span><br><span class="line">println(map)  <span class="comment">//结果 &#123;1=AAA, 2=BBB, 3=CCC&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="解压操作"><a href="#解压操作" class="headerlink" title="解压操作"></a>解压操作</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span> to <span class="string">&quot;AAA&quot;</span>, <span class="number">2</span> to <span class="string">&quot;BBB&quot;</span>, <span class="number">3</span> to <span class="string">&quot;CCC&quot;</span>)  <span class="comment">//把合在一起的Pair每个元素都分开</span></span><br><span class="line"><span class="keyword">val</span> unzipList: Pair&lt;List&lt;<span class="built_in">Int</span>&gt;, List&lt;String&gt;&gt; = list.unzip()  <span class="comment">//转换出来是一个存放两个List的Pair</span></span><br><span class="line"><span class="comment">//Pair的key是所有key的列表，value是所有value的列表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="associate操作"><a href="#associate操作" class="headerlink" title="associate操作"></a><code>associate</code>操作</h4><p>将普通集合转换为Map映射</p>
<ol>
<li><code>associateWith</code>：以列表中每个元素为Key，提供一个函数，返回值作为生成的Map对应Key的Value</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>)</span><br><span class="line"><span class="comment">//使用associateWith快速构建以列表中每个元素为Key的Map映射</span></span><br><span class="line"><span class="keyword">val</span> associate: Map&lt;String, <span class="built_in">Int</span>&gt; = list.associateWith &#123; it.length &#125;   <span class="comment">//提供一个函数，返回值作为生成的Map对应Key的Value</span></span><br><span class="line"><span class="comment">//结果 &#123;AAA=3, BBB=3, CCC=3&#125;</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><code>associateBy</code>：构建以列表中每个元素为Value的Map映射，返回值作为生成的Map对应Value的Key</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>)</span><br><span class="line"><span class="comment">//使用associateBy快速构建以列表中每个元素为Value的Map映射</span></span><br><span class="line"><span class="keyword">val</span> associate: Map&lt;<span class="built_in">Int</span>, String&gt; = list.associateBy &#123; it.length &#125;   <span class="comment">//提供一个函数，返回值作为生成的Map对应Value的Key</span></span><br><span class="line"><span class="comment">//结果&#123;3=CCC&#125;，因为上面生产出来的Key全是3，覆盖完只剩下最后一个了</span></span><br></pre></td></tr></table></figure>

<ul>
<li>由于列表的元素是可以重复的，但是Map的Key是不能重复的，所以，当有多个重复的，当生成了多个重复的key时，以最后一个为主</li>
</ul>
<ol start="3">
<li><code>associate</code>：自行构建一个Pair作为结果返回</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> associate: Map&lt;String, <span class="built_in">Int</span>&gt; = list.associate &#123; it to it.length &#125;  <span class="comment">//返回一个Pair</span></span><br></pre></td></tr></table></figure>



<h4 id="扁平化操作"><a href="#扁平化操作" class="headerlink" title="扁平化操作"></a>扁平化操作</h4><p>把这个嵌套的集合内所有的集合全部拆出来</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(listOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>), listOf(<span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;DDD&quot;</span>))</span><br><span class="line"><span class="keyword">val</span> flatten: List&lt;String&gt; = list.flatten()   <span class="comment">//使用flatten函数将嵌套集合扁平化</span></span><br><span class="line"><span class="comment">//可以看到内容自动被展平了 [AAA, BBB, CCC, DDD]</span></span><br></pre></td></tr></table></figure>



<h4 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h4><p>将扁平的集合嵌套</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;DDD&quot;</span>)</span><br><span class="line"><span class="comment">//使用chunked进行分块，这里2个元素为一组进行分块，得到一个嵌套的集合</span></span><br><span class="line">println(list.chunked(<span class="number">2</span>))   <span class="comment">//结果 [[AA, BBB], [CC, DDD]]</span></span><br></pre></td></tr></table></figure>





<h4 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h4><p>提供一个函数作为过滤标准，返回一个新的集合</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">filter</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: List&lt;T&gt;</span><br></pre></td></tr></table></figure>



<p>快速过滤所有空值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;AAA&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;BBB&quot;</span>, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">val</span> filterList: List&lt;String&gt; = list.filterNotNull()</span><br><span class="line">println(filterList)   <span class="comment">//结果 [AAA, BBB]</span></span><br></pre></td></tr></table></figure>



<p>快速过滤出指定类型的集合</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;AAA&quot;</span>, Any(), <span class="string">&quot;BBB&quot;</span>, <span class="number">123</span>, <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">val</span> filterList: List&lt;String&gt; = list.filterIsInstance&lt;String&gt;()  <span class="comment">//快速过滤出所有的String元素</span></span><br><span class="line">println(filterList)   <span class="comment">//结果 [AAA, BBB]</span></span><br></pre></td></tr></table></figure>



<h4 id="分区操作"><a href="#分区操作" class="headerlink" title="分区操作"></a>分区操作</h4><p>过滤操作可以快速筛选出我们需要的那些元素，当然，如果我们既需要筛选出来的元素，也需要筛选出去的元素，我们可以使用分区操作</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">partition</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: Pair&lt;List&lt;T&gt;, List&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;DDD&quot;</span>)</span><br><span class="line"><span class="comment">//分区操作得到一个匹配列表和一个不匹配列表</span></span><br><span class="line"><span class="keyword">val</span> (match, mismatch) = list.partition &#123; it.length &gt; <span class="number">2</span> &#125;</span><br><span class="line">println(<span class="string">&quot;匹配的列表: <span class="variable">$match</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;不匹配的列表: <span class="variable">$mismatch</span>&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="分组操作"><a href="#分组操作" class="headerlink" title="分组操作"></a>分组操作</h4><p>它可以将元素按类别进行分组，以Map的形式返回：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;DDD&quot;</span>)</span><br><span class="line">println(list.groupBy &#123; it.length &#125;)  <span class="comment">//按照字符串的长度进行分组</span></span><br><span class="line"><span class="comment">//得到 &#123;2=[AA, CC], 3=[BBB, DDD]&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/collections-overview.html">https://kotlinlang.org/docs/collections-overview.html</a></p>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>除了集合，Kotlin标准库还包含另一种类型：<em>序列</em>（<a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html"><code>Sequence</code></a>）与集合不同，序列不包含元素，它在运行时生成元素</p>
<p><code>Sequence</code>接口与<code>Iterable</code>接口类似，只包含一个生成迭代器的函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sequence</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成迭代器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>性能优化—惰性</strong></li>
</ul>
<p>序列实际上是一个延迟获取数据的集合，只有需要元素时才会生产元素，并提供给外部，包括所有对元素操作，并不是一次性全部处理，而是根据情况选择合适的元素进行操作。使用序列能够在处理大量数据时获得显著的性能提升</p>
<p>序列并不是随时随地都可以使用的，我们还是要根据实际情况决定是否要使用序列，如果在数据量特别庞大的情况下，使用序列处理会更好，但是如果数据量很小，使用序列反而会增加开销</p>
<h1 id="Kotlin特殊类型"><a href="#Kotlin特殊类型" class="headerlink" title="Kotlin特殊类型"></a>Kotlin特殊类型</h1><h2 id="数据类型-data-class"><a href="#数据类型-data-class" class="headerlink" title="数据类型(data class)"></a>数据类型(data class)</h2><p>Kotlin为我们提供了专门的数据类，数据类不仅能像普通类一样使用，并且自带我们需要的额外成员函数，比如打印到输出、比较实例、复制实例等</p>
<p>数据类声明后，编译器会根据<strong>主构造函数</strong>中声明的所有属性自动为其生成以下函数：</p>
<ul>
<li><code>.equals()</code>&#x2F;<code>.hashCode()</code></li>
<li><code>.toString()</code>生成的字符串格式</li>
<li><code>.componentN()</code>与按声明顺序自动生成用于解构的函数</li>
<li><code>.copy()</code>用于对对象进行拷贝(浅拷贝)</li>
</ul>
<p>注意，编译器会且只会根据主构造函数中定义的属性生成对应函数，如果有些时候我们不希望某些属性被添加到自动生成的函数中，我们需要手动将其移出主构造函数，用辅助函数初始化</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String)&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">18</span> <span class="comment">//age属性不会被处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>):<span class="keyword">this</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="枚举类型-enum-class"><a href="#枚举类型-enum-class" class="headerlink" title="枚举类型(enum class)"></a>枚举类型(enum class)</h2><p>用于表示一组固定的常量值</p>
<h3 id="定义枚举类"><a href="#定义枚举类" class="headerlink" title="定义枚举类"></a>定义枚举类</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类前面添加enum表示这是一个枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">LightState</span> &#123;</span><br><span class="line">    GREEN, YELLOW, RED   <span class="comment">//直接在枚举类内部写上所有枚举的名称，一般全部用大写字母命名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类的值只能是我们在类中定义的那些枚举，不可以存在其他的结果，枚举类型同样也是一个普通的类，只是存在值的限制。</p>
<h3 id="定义成员"><a href="#定义成员" class="headerlink" title="定义成员"></a>定义成员</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同样可以定义成员变量，但是不能命名为name，因为name拿来返回枚举名称了</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">LightState</span>(<span class="keyword">val</span> color: String) &#123;</span><br><span class="line">    GREEN(<span class="string">&quot;绿灯&quot;</span>), YELLOW(<span class="string">&quot;黄灯&quot;</span>), RED(<span class="string">&quot;红灯&quot;</span>);  <span class="comment">//枚举在定义时也必须填写参数，如果后面还要编写成员函数之类的其他内容，还需在末尾添加分号结束</span></span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">fun</span> <span class="title">isGreen</span><span class="params">()</span></span> = <span class="keyword">this</span> == LightState.GREEN  <span class="comment">//定义一个函数也是没问题的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="枚举中的抽象函数"><a href="#枚举中的抽象函数" class="headerlink" title="枚举中的抽象函数"></a>枚举中的抽象函数</h3><p>在枚举类中也可以编写抽象函数，抽象函数需要由枚举自行实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">LightState</span> &#123;</span><br><span class="line">    GREEN&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;我是绿灯&quot;</span>)</span><br><span class="line">    &#125;, YELLOW&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;我是黄灯&quot;</span>)</span><br><span class="line">    &#125;, RED&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;我是红灯&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="枚举中的接口"><a href="#枚举中的接口" class="headerlink" title="枚举中的接口"></a>枚举中的接口</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">LightState</span> : <span class="type">Message</span>&#123;</span><br><span class="line">    GREEN&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;我是绿灯&quot;</span>)</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span> = println(<span class="string">&quot;绿灯行&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;, YELLOW&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;我是黄灯&quot;</span>)</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span> = println(<span class="string">&quot;黄灯减速&quot;</span>)</span><br><span class="line">    &#125;, RED&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;我是红灯&quot;</span>)</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span> = println(<span class="string">&quot;红灯停&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以在这里统一实现</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span> &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="枚举的其他函数"><a href="#枚举的其他函数" class="headerlink" title="枚举的其他函数"></a>枚举的其他函数</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> state: LightState = LightState.valueOf(<span class="string">&quot;RED&quot;</span>)   <span class="comment">//通过valueOf函数以字符串名称的形式转换为对应名称的枚举</span></span><br><span class="line"><span class="keyword">val</span> state: LightState = enumValueOf&lt;LightState&gt;(<span class="string">&quot;RED&quot;</span>)   <span class="comment">//同上</span></span><br><span class="line">println(state)</span><br><span class="line">println(state.ordinal)   <span class="comment">//枚举在第几个位置</span></span><br><span class="line">println(state.name)   <span class="comment">//枚举名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> entries: EnumEntries&lt;LightState&gt; = LightState.entries  <span class="comment">//一键获取全部枚举，得到的结果是EnumEntries类型的，他是List的子接口，因此可以当做List来使用</span></span><br><span class="line"><span class="keyword">val</span> values: Array&lt;LightState&gt; = enumValues&lt;LightState&gt;()   <span class="comment">//或者像这样以Array形式获取到所有的枚举</span></span><br><span class="line">println(entries)</span><br></pre></td></tr></table></figure>





<h2 id="匿名类和伴生对象"><a href="#匿名类和伴生对象" class="headerlink" title="匿名类和伴生对象"></a>匿名类和伴生对象</h2><p>在某些时候，我们只需要临时使用一下某个类，并不需要通过class关键字定义对象，而是以匿名的形式创建一个临时对象，在使用完之后就不再需要了，这种情况完全没有必要定义一个完成的类型，而是可以使用匿名类的方式（特别是某些接口）</p>
<p><strong>在需要创建一个只使用一次的类实例</strong></p>
<h3 id="匿名类的创建object"><a href="#匿名类的创建object" class="headerlink" title="匿名类的创建object"></a>匿名类的创建<code>object</code></h3><p>匿名类除了没名字之外，也可以定义成员，只不过这种匿名类不能定义任何构造函数，因为它是直接创建的，这种写法我们也可以叫做<strong>对象表达式</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用object关键字声明一个匿名类并创建其对象，可以直接使用变量接收得到的对象</span></span><br><span class="line"><span class="keyword">val</span> obj = <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;匿名类&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String =<span class="string">&quot;我是<span class="subst">$&#123;name&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(obj)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>object</code>关键字：声明一个匿名类并创建其对象，可以直接使用变量接收得到的对象</li>
<li><em>匿名类默认继承于Any</em></li>
</ul>
<h3 id="继承-抽象类，接口，类"><a href="#继承-抽象类，接口，类" class="headerlink" title="继承 抽象类，接口，类"></a>继承 抽象类，接口，类</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> :Message&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span>= println(<span class="string">&quot;我是匿名类实现接口&quot;</span>)</span><br><span class="line">    &#125;.speakMessage()</span><br></pre></td></tr></table></figure>



<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>对于只存在一个抽象函数的接口称为<strong>函数式接口</strong>或<strong>单一抽象方法（SAM）接口</strong>，函数式接口可以有N个非抽象成员，但是<strong>只能有一个抽象成员</strong>。对于函数式接口，可以使用我们前面介绍的Lambda表达式来使代码更简洁</p>
<p>**函数式接口：**一个抽象成员，多个非抽象成员</p>
<h4 id="定义函数式接口"><a href="#定义函数式接口" class="headerlink" title="定义函数式接口"></a>定义函数式接口</h4><p>在interface之前使用fun关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在接口声明前面添加fun关键字，声明这是一个函数式接口</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Message &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Lambda来定义函数式接口中的抽象成员</span></span><br><span class="line"><span class="keyword">val</span> message = Message&#123;</span><br><span class="line">        println(<span class="string">&quot;我是函数式接口&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="因为匿名产生的些许问题"><a href="#因为匿名产生的些许问题" class="headerlink" title="因为匿名产生的些许问题"></a>因为匿名产生的些许问题</h3><p>因为有了匿名类，所以有些时候我们通过函数得到的结果，可能并不是某个具体定义的类型，也有可能是直接采用匿名形式创建的匿名类对象，这是返回的对象只能当作匿名类继承的类使用</p>
<p>例如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Human</span>(<span class="keyword">var</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>= <span class="keyword">object</span>: Human(<span class="string">&quot;小帅&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> age:<span class="built_in">Int</span>=<span class="number">20</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">&quot;我是<span class="variable">$name</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> test:Human = test()<span class="comment">//返回的类型是Human，由于其匿名特性，只能当做Human使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="单例类型"><a href="#单例类型" class="headerlink" title="单例类型"></a>单例类型</h2><p><code>object</code>关键字不仅可以用于声明匿名类型，也可以用于声明<strong>单例类</strong></p>
<ul>
<li>单例类：在整个程序中只能存在一个对象，也就是单个实例，不可以创建其他的对象，始终使用的只能是那一个对象</li>
</ul>
<p>通过类名直接得到此单例类的对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name = <span class="string">&quot;单例&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">&quot;我是<span class="subst">$&#123;name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> singleton = Singleton   <span class="comment">//通过类名直接得到此单例类的对象</span></span><br><span class="line">    <span class="comment">//不可以通过构造函数的形式创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>单例类的这种性质在很多情况下都很方便，比如我们要编写某些工具操作，可以直接使用单例类的形式编写</p>
</blockquote>
<h2 id="伴生对象-有种java中的static的感jio"><a href="#伴生对象-有种java中的static的感jio" class="headerlink" title="伴生对象(有种java中的static的感jio)"></a>伴生对象(有种java中的static的感jio)</h2><p>既希望像单例类那样直接调用，又支持像一个普通class那样使用，这时就可以使用伴生对象来实现</p>
<p>实际上就是将一个单例类<strong>写到某个类的内部</strong></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>使用companion关键字在内部编写一个伴生对象，它同样是单例的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String , <span class="keyword">var</span> age: <span class="built_in">Int</span> , <span class="keyword">var</span> id:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="comment">//使用companion关键字在内部编写一个伴生对象，它同样是单例的</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Tools&#123;</span><br><span class="line">        <span class="keyword">var</span> tempId:<span class="built_in">Int</span>=<span class="number">0</span></span><br><span class="line">        <span class="comment">//伴生对象定义的函数可以直接通过外部类名调用</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(name: <span class="type">String</span>,age: <span class="type">Int</span>)</span></span>:Student&#123;</span><br><span class="line">           tempId+=<span class="number">1</span></span><br><span class="line">           <span class="keyword">return</span> Student(name,age, tempId)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> createStudent:(name:String,age:<span class="built_in">Int</span>)-&gt;Student=&#123;name: String, age: <span class="built_in">Int</span> -&gt;</span><br><span class="line">            tempId+=<span class="number">1</span></span><br><span class="line">            Student(name,age, tempId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用companion关键字在内部编写一个伴生对象，它同样是单例的</li>
<li>伴生对象定义的函数可以直接通过外部类名调用</li>
</ul>
<h2 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h2><p>继承的一种更好的替代方案</p>
<h3 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h3><p>比如现在我们有一个接口</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Message</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此时我们创建一个实现Message接口的类，该类有一个实现该接口的对象<code>messageImpl</code></p>
<p>在重写Message的接口的方法时，调用<code>messageImpl</code>对于方法的实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="keyword">var</span> messageImpl: Message) : Message &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span> = messageImpl.speakMessage() </span><br><span class="line">    <span class="comment">//真正去实现这个接口的，实际上并不是当前类，而是被拉进来的那个替身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A委托别人去完成方法</p>
<h3 id="原始支持by"><a href="#原始支持by" class="headerlink" title="原始支持by"></a>原始支持<code>by</code></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="keyword">val</span> messageImpl: Message) : Message <span class="keyword">by</span> messageImpl</span><br></pre></td></tr></table></figure>



<h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> p: String <span class="keyword">by</span> lazy &#123; <span class="string">&quot;ddd&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lazy为我们生成一个委托对象，这样在获取属性值的时候就会执行lazy里面的操作了，看起来效果就像是延迟执行一样，由于只能获取，所以说只支持val变量</span></span><br></pre></td></tr></table></figure>

<p>获取属性值的时候就会执行lazy里面的操作了，看起来效果就像是延迟执行一样，由于只能获取，所以说只支持val变量</p>
<h4 id="设置检测器"><a href="#设置检测器" class="headerlink" title="设置检测器"></a>设置检测器</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> p: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;我是初始值&quot;</span>)&#123;property, oldValue, newValue -&gt;</span><br><span class="line">        println(<span class="string">&quot;检测到<span class="subst">$&#123;property&#125;</span>的值发生变化,<span class="subst">$&#123;oldValue&#125;</span>-&gt;<span class="subst">$&#123;newValue&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>有些时候，我们可能会编写一些类给其他人使用，但是我们不希望他们随意继承使用我们提供的类，我们只希望在我们提供的框架内部自己进行使用，这时我们就可以将类或接口设定为密封的</p>
<ul>
<li><p><code>sealed</code>密封类声明</p>
</li>
<li><p>密封类同一个模块或包中可以随意继承，并且子类也可以是密封的</p>
</li>
<li><p>密封类本身是抽象的</p>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h3><blockquote>
<p>kotlin.Throwable<br>│<br>├── kotlin.Exception<br>│   ├── java.lang.RuntimeException<br>│   │   ├── java.lang.NullPointerException<br>│   │   ├── java.lang.IllegalArgumentException<br>│   │   ├── java.lang.IllegalStateException<br>│   │   ├── java.lang.IndexOutOfBoundsException<br>│   │   └── java.lang.ClassCastException<br>│   ├── java.io.IOException<br>│   └── java.lang.InterruptedException<br>│</p>
<p>│</p>
<p>└── kotlin.Error<br> ├── java.lang.OutOfMemoryError<br> ├── java.lang.StackOverflowError<br> └── java.lang.VirtualMachineError</p>
</blockquote>
<h4 id="Throwable类"><a href="#Throwable类" class="headerlink" title="Throwable类"></a>Throwable类</h4><p><code>Throwable</code> 是所有异常和错误的根类。</p>
<p><code>Throwable</code> 的重要属性：</p>
<ul>
<li><code>message</code>：异常的描述信息。</li>
<li><code>cause</code>：导致该异常的根本原因。</li>
</ul>
<p>具有两个常用的构造函数：</p>
<p>constructor(message: String?) : this(message, null)</p>
<p>constructor(cause: Throwable?) : this(cause?.toString(), cause)</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span> (e:Exception)&#123;</span><br><span class="line">    println(e)</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;执行 finally 块&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span>():Exception(<span class="string">&quot;自定义异常&quot;</span>)</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Kotlin基础</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://blog.hi-ir.top/2025/03/05/Kotlin基础/">https://blog.hi-ir.top/2025/03/05/Kotlin基础/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>HI-IR</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-03-05</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-03-05</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0/">安卓学习</a></div><div class="post-share"><div class="social-share" data-image="/img/tit.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/10/%E5%B9%BF%E6%92%AD/" title="广播"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">广播</div></div><div class="info-2"><div class="info-item-1">广播简介 标准广播：完全异步，所有的BroadcastReceiver几乎会在同一时刻收到该条广播，不可截断  有序广播：同步执行，同一时刻只会有一个BroadcastReceiver接收到，可以选择是否截断   更多系统广播消息\platforms&lt;Android api版本&gt;\data\broadcast_actions.txt 注册BroadcastReceiver分类：静态注册（在AndroidManifest.xml中注册），动态注册（在代码中注册） 动态注册 新建一个类，继承BroadcastReceiver类，重写父类onReceiver()  12345inner class TimeChangeReceiver : BroadcastReceiver()&#123;    override fun onReceive(p0: Context?, p1: Intent?) &#123;        Toast.makeText(p0,&quot;时间改变了&quot;,Toast.LENGTH_SHORT).show()   ...</div></div></div></a><a class="pagination-related" href="/2025/03/05/ViewBinding/" title="ViewBinding"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ViewBinding</div></div><div class="info-2"><div class="info-item-1">ViewBinding什么是ViewBinding为了避免编写findViewById()而产生的一个插件 旧的kotlin-android-extensions已被放用 安装在你项目工程模块的build.gradle中，开启viewBinding 123456android&#123;    ...    buildFeatures&#123;        viewBinding true    &#125;&#125;      Activity中使用启动了ViewBinding功能之后，Android...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/01/17/SQL%E6%8C%87%E4%BB%A4/" title="SQL指令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-17</div><div class="info-item-2">SQL指令</div></div><div class="info-2"><div class="info-item-1">SQL指令 可以使用SQL命令进行关系型数据库操作   注: 不同的关系型管理系统可能有不同的指令  持续更新(学到哪更到哪) SQL概述 SQL指令主要分为：数据定义，数据操纵，数据查询，数据控制，事务控制等  数据定义(DDL)​	创建和修改盛放数据的容器 数据操纵(DML)​	表中添加，修改，删除数据 数据查询(DQL)​	表中数据多条件查询（最复杂的！！！） 事务控制(TCL) 与 数据控制(DCL)​	事务启动，提交，回滚(事务控制) ​	账号创建，权限控制(数据控制) 注： 数据定义，数据操纵，数据查询	是重点  学习路线 DDL - DML - DQL  - TCL - DCL  一条数据的存储过程创建库 -&gt; 定字段 -&gt; 创建表 -&gt; 插数据 基础操作连接mysql服务1mysql -u&lt;username&gt; -p&lt;password&gt; -h&lt;hostname&gt; -P&lt;port&gt; &lt;databassname&gt;   -u：用户名  -p：密码（-p后面不带空格...</div></div></div></a><a class="pagination-related" href="/2025/01/18/MVP%E6%9E%B6%E6%9E%84/" title="MVP架构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-18</div><div class="info-item-2">MVP架构</div></div><div class="info-2"><div class="info-item-1">MVP架构概述三个核心组件组成：Model（模型）、View（视图）和 Presenter（展示器） 把原来的UI逻辑抽象成View接口，把原来的业务逻辑抽象成Presenter接口，model还是原来的modle  Model（模型）：  **定义:**负责处理应用程序的数据逻辑，包括与数据库、网络、API等数据源的交互 **职责:**提供数据，并将其返回给 Presenter，不涉及任何UI相关逻辑  View（视图）：  **定义:**负责展示用户界面，接收用户的输入并将其传递给 Presenter  **职责:**展示由 Presenter 提供的数据，并根据用户操作调用 Presenter 的方法。View 层不直接处理逻辑，只展示内容   Presenter（演示者）：  **定义：**作为 View 和 Model 之间的桥梁，负责处理逻辑和协调数据流  职责：  从 View 接收用户输入，调用 Model 获取数据 将数据处理结果返回给 View 以更新UI Presenter 不直接操作UI，而是通过接口与 View...</div></div></div></a><a class="pagination-related" href="/2025/01/19/DrawerLayout-NavigationView%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E8%8F%9C%E5%8D%95/" title="DrawerLayout-NavigationView实现滑动菜单"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-19</div><div class="info-item-2">DrawerLayout-NavigationView实现滑动菜单</div></div><div class="info-2"><div class="info-item-1">DrawerLayout-NavigationView实现滑动菜单DrawerLayoutDrawerLayout介绍 DrawerLayout 提供了一种简单而直观的方式来让用户访问应用的不同部分或功能模块  DrawerLayout 是 Android 中用于实现侧边导航栏的一个重要组件。  DrawerLayout的实现XML布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;   ...</div></div></div></a><a class="pagination-related" href="/2025/01/20/BottomNavigationView/" title="BottomNavigationView"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-20</div><div class="info-item-2">BottomNavigationView</div></div><div class="info-2"><div class="info-item-1">BottomNavigationView导入新包1implementation...</div></div></div></a><a class="pagination-related" href="/2025/01/20/ToolBar%E6%8E%A7%E4%BB%B6/" title="ToolBar控件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-20</div><div class="info-item-2">ToolBar控件</div></div><div class="info-2"><div class="info-item-1">ToolBar控件常用属性1234&lt;androidx.appcompat.widget.Toolbar    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;?android:attr/actionBarSize&quot;//工具条高度和界面保持一致(默认56dp)   ...</div></div></div></a><a class="pagination-related" href="/2025/01/20/ViewPager2%E5%92%8CBottomNavigationView%E7%9A%84%E8%81%94%E5%8A%A8/" title="ViewPager2和BottomNavigationView的联动"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-20</div><div class="info-item-2">ViewPager2和BottomNavigationView的联动</div></div><div class="info-2"><div class="info-item-1">ViewPager2和BottomNavigationView的联动ViewPager2对BottomNavigationView的控制实现ViewPager2左右滑动控制BottomNavigationView的menu的控制 12mViewPager2.registerOnPageChangeCallback(......);//检测Page的变化mBottomNavigationView.setSelectedItemId(R.id.xxx)//设置BottomNavigationView的menu被选中的选项     实例  123456789101112131415161718ViewPager2.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() &#123;            @Override            public void onPageScrolled(int position, float positionOffset, int...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/tit.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">HI-IR</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/HI-IR"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Kotlin%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Kotlin基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">变量的定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">创建函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%B8%8Elambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%8C%E9%97%AD%E5%8C%85"><span class="toc-number">1.2.2.</span> <span class="toc-text">高阶函数与lambda表达式，匿名函数，闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">高阶函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">Lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">中缀函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">面对对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">类的创建，使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">对象的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">类成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%88%E6%88%91%E6%98%AF%E5%9C%A8%E5%AD%A6C-%E5%90%97%EF%BC%9F%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">运算符重载（我是在学C++吗？）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AF%B9%E5%BA%94%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">常见的一些运算符对应的函数名称</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.3.5.</span> <span class="toc-text">中缀函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E5%80%BC%E5%92%8C-%E5%8F%AF-%E7%A9%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.6.</span> <span class="toc-text">空值和(可)空类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.7.</span> <span class="toc-text">空合并操作符?:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E5%A3%B0%E6%98%8E"><span class="toc-number">1.3.8.</span> <span class="toc-text">解构声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%EF%BC%88%E5%92%8Cjava%E6%9C%89%E4%BA%9B%E4%B8%8D%E5%90%8C%EF%BC%89"><span class="toc-number">1.3.9.</span> <span class="toc-text">权限控制（和java有些不同）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81"><span class="toc-number">1.4.</span> <span class="toc-text">封装继承多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.4.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.4.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">1.4.3.</span> <span class="toc-text">方法与属性的重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.4.4.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Any%E7%B1%BB"><span class="toc-number">1.4.5.</span> <span class="toc-text">Any类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BDequals"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">运算符重载equals</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.4.6.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.7.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">1.4.8.</span> <span class="toc-text">类的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%98%E9%87%8F%E6%97%B6"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">当扩展函数作为参数赋值给变量时</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kotlin%E8%BF%9B%E9%98%B6"><span class="toc-number">2.</span> <span class="toc-text">Kotlin进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">2.1.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">有关泛型的继承问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">泛型函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.1.1.4.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E9%AB%98%E9%98%B6%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">官方高阶扩展函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Any-apply-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">Any.apply()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Any-let-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">Any.let()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Any-also-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">Any.also()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Any-run-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">Any.run()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Any-takeIf-%E5%87%BD%E6%95%B0%E4%B8%8EAny-takeUnless-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.6.</span> <span class="toc-text">Any.takeIf()函数与Any.takeUnless()函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98%E3%80%81%E9%80%86%E5%8F%98%E3%80%81%E6%8A%97%E5%8F%98"><span class="toc-number">2.1.3.</span> <span class="toc-text">*协变、逆变、抗变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="toc-number">2.1.4.</span> <span class="toc-text">通配符（*）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%95%8C%E9%99%90"><span class="toc-number">2.1.5.</span> <span class="toc-text">*泛型界限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8A%E7%95%8C"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">定义上界</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">2.1.6.</span> <span class="toc-text">*类型擦除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">内联泛型函数的类型擦除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">创建数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">打印</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">比较两个数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">拷贝数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">查找元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">2.2.2.6.</span> <span class="toc-text">排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E5%8F%82%E6%95%B0%EF%BC%8C%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.3.</span> <span class="toc-text">可变长度参数，扩展运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.4.</span> <span class="toc-text">原生类型数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">嵌套数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E9%9B%86%E5%90%88"><span class="toc-number">2.3.1.</span> <span class="toc-text">List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98List%E9%9B%86%E5%90%88MutableList"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">可变List集合MutableList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88List"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">不可变集合List</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88"><span class="toc-number">2.3.2.</span> <span class="toc-text">Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98Set%E9%9B%86%E5%90%88-MutableSet"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">可变Set集合 MutableSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98Set%E9%9B%86%E5%90%88-Set"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">不可变Set集合 Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">集合操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%94%A8%E4%BA%8E%E5%88%9B%E5%BB%BA%E7%9A%84%E9%A2%84%E8%AE%BE%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">其他用于创建的预设函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.2.5.</span> <span class="toc-text">HashSet判断元素是否相同的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99equlas-%E7%9A%84%E5%90%8C%E6%97%B6%EF%BC%8C%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashCode"><span class="toc-number">2.3.2.6.</span> <span class="toc-text">重写equlas()的同时，必须重写hashCode()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-number">2.3.3.</span> <span class="toc-text">Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">键值对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAMap"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">创建Map</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98Map%E9%9B%86%E5%90%88-MutableMap"><span class="toc-number">2.3.3.2.1.</span> <span class="toc-text">可变Map集合(MutableMap)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98Map%E9%9B%86%E5%90%88-Map"><span class="toc-number">2.3.3.2.2.</span> <span class="toc-text">不可变Map集合(Map)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">增</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0"><span class="toc-number">2.3.3.4.</span> <span class="toc-text">删</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9"><span class="toc-number">2.3.3.5.</span> <span class="toc-text">改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5"><span class="toc-number">2.3.3.6.</span> <span class="toc-text">查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-number">2.3.3.7.</span> <span class="toc-text">遍历集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.3.4.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%EF%BC%8C%E9%9B%86%E5%90%88"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">遍历数组，集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Iterable%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">实现Iterable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ListIterator"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">ListIterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MutableIterator"><span class="toc-number">2.3.4.4.</span> <span class="toc-text">MutableIterator</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.5.</span> <span class="toc-text">集合与数组的扩展操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84to%E9%9B%86%E5%90%88"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">数组to集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84map"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">映射map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.5.3.</span> <span class="toc-text">压缩操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.5.4.</span> <span class="toc-text">解压操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#associate%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.5.5.</span> <span class="toc-text">associate操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%81%E5%B9%B3%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.5.6.</span> <span class="toc-text">扁平化操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%9D%97"><span class="toc-number">2.3.5.7.</span> <span class="toc-text">分块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.5.8.</span> <span class="toc-text">过滤操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.5.9.</span> <span class="toc-text">分区操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.5.10.</span> <span class="toc-text">分组操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">2.3.5.11.</span> <span class="toc-text">其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97"><span class="toc-number">2.4.</span> <span class="toc-text">序列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kotlin%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">Kotlin特殊类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-data-class"><span class="toc-number">3.1.</span> <span class="toc-text">数据类型(data class)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B-enum-class"><span class="toc-number">3.2.</span> <span class="toc-text">枚举类型(enum class)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">定义枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98"><span class="toc-number">3.2.2.</span> <span class="toc-text">定义成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.3.</span> <span class="toc-text">枚举中的抽象函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.4.</span> <span class="toc-text">枚举中的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.5.</span> <span class="toc-text">枚举的其他函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%92%8C%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.</span> <span class="toc-text">匿名类和伴生对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BAobject"><span class="toc-number">3.3.1.</span> <span class="toc-text">匿名类的创建object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%EF%BC%8C%E7%B1%BB"><span class="toc-number">3.3.2.</span> <span class="toc-text">继承 抽象类，接口，类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.3.3.</span> <span class="toc-text">函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">定义函数式接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E4%B8%BA%E5%8C%BF%E5%90%8D%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BA%9B%E8%AE%B8%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.4.</span> <span class="toc-text">因为匿名产生的些许问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">单例类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1-%E6%9C%89%E7%A7%8Djava%E4%B8%AD%E7%9A%84static%E7%9A%84%E6%84%9Fjio"><span class="toc-number">3.5.</span> <span class="toc-text">伴生对象(有种java中的static的感jio)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">3.5.1.</span> <span class="toc-text">定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">委托模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.6.1.</span> <span class="toc-text">手动实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%94%AF%E6%8C%81by"><span class="toc-number">3.6.2.</span> <span class="toc-text">原始支持by</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">懒加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%A3%80%E6%B5%8B%E5%99%A8"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">设置检测器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB"><span class="toc-number">3.6.3.</span> <span class="toc-text">密封类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">3.7.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84"><span class="toc-number">3.7.1.</span> <span class="toc-text">继承结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Throwable%E7%B1%BB"><span class="toc-number">3.7.1.1.</span> <span class="toc-text">Throwable类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">3.7.2.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">3.7.3.</span> <span class="toc-text">自定义异常</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/10/%E5%B9%BF%E6%92%AD/" title="广播">广播</a><time datetime="2025-03-10T14:34:01.000Z" title="发表于 2025-03-10 22:34:01">2025-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/05/Kotlin%E5%9F%BA%E7%A1%80/" title="Kotlin基础">Kotlin基础</a><time datetime="2025-03-05T15:33:30.000Z" title="发表于 2025-03-05 23:33:30">2025-03-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/05/ViewBinding/" title="ViewBinding">ViewBinding</a><time datetime="2025-03-05T09:37:56.000Z" title="发表于 2025-03-05 17:37:56">2025-03-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/31/OkHttp%E4%B8%8ERetrofit/" title="OkHttp与Retrofit">OkHttp与Retrofit</a><time datetime="2025-01-31T09:10:48.000Z" title="发表于 2025-01-31 17:10:48">2025-01-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/23/ROOM%E6%A1%86%E6%9E%B6/" title="ROOM框架">ROOM框架</a><time datetime="2025-01-23T09:00:30.000Z" title="发表于 2025-01-23 17:00:30">2025-01-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By HI-IR</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>