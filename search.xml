<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>权限控制</title>
      <link href="/2025/03/11/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
      <url>/2025/03/11/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="安卓权限控制"><a href="#安卓权限控制" class="headerlink" title="安卓权限控制"></a>安卓权限控制</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><p>普通权限：系统自动帮我们进行授权，不需要用户处理</p></li><li><p>危险权限：可能会触及隐私或者对设备安全性造成影响的权限，这些权限需要用户在运行时（Android 6.0+）显式授予。</p><p>可能会触发权限请求对话框。</p></li><li><p>特殊权限</p></li></ul><h2 id="危险权限-运行时权限"><a href="#危险权限-运行时权限" class="headerlink" title="危险权限(运行时权限)"></a>危险权限(运行时权限)</h2><p>11组30个</p><table><thead><tr><th>权限组</th><th>权限</th></tr></thead><tbody><tr><td>CALENDAR (日历)</td><td>READ_CALENDAR <br />WRITE_CALENDAR</td></tr><tr><td>CAMERA (相机)</td><td>CAMERA</td></tr><tr><td>CONTACTS (联系人)</td><td>READ_CONTACTS <br />WRITE_CONTACTS <br />GET_ACCOUNTS</td></tr><tr><td>LOCATION (位置)</td><td>ACCESS_FINE_LOCATION <br />ACCESS_COARSE_LOCATION</td></tr><tr><td>MICROPHONE (麦克风)</td><td>RECORD_AUDIO</td></tr><tr><td>PHONE (手机)</td><td>READ_PHONE_STATE <br />CALL_PHONE <br />READ_CALL_LOG<br /> WRITE_CALL_LOG <br />ADD_VOICEMAIL <br />USE_SIP <br />PROCESS_OUTGOING_CALLS</td></tr><tr><td>SENSORS (传感器)</td><td>BODY_SENSORS</td></tr><tr><td>SMS (短信)</td><td>SEND_SMS <br />RECEIVE_SMS <br />READ_SMS <br />RECEIVE_WAP_PUSH <br />RECEIVE_MMS</td></tr><tr><td>STORAGE (存储卡)</td><td>READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE</td></tr></tbody></table><h3 id="运行时申请"><a href="#运行时申请" class="headerlink" title="运行时申请"></a>运行时申请</h3><p>一、在AndroidManifest.xml中注册权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CALL_PHONE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>二、在Android6.0以上需要进行运行时权限处理</p><p>先看代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">binding.btnMainCall.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">//检查是否有权限step1</span></span><br><span class="line">            <span class="keyword">if</span>(ContextCompat.checkSelfPermission(<span class="keyword">this</span>,</span><br><span class="line">                    Manifest.permission.CALL_PHONE) == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                doCall()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//申请权限step2</span></span><br><span class="line">                ActivityCompat.requestPermissions(<span class="keyword">this</span>, arrayOf(Manifest.permission.CALL_PHONE),<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理申请权限的返回结果step3</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        requestCode: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        grantResults: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">        <span class="keyword">when</span>(requestCode)&#123;</span><br><span class="line">            <span class="number">1</span> -&gt; <span class="keyword">if</span>(grantResults.isNotEmpty() &amp;&amp;</span><br><span class="line">                grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                doCall()</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>,<span class="string">&quot;你拒绝了申请&quot;</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打电话，调用权限</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doCall</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            intent= Intent(Intent.ACTION_CALL)</span><br><span class="line">            intent.<span class="keyword">data</span> = Uri.parse(<span class="string">&quot;10086&quot;</span>)</span><br><span class="line">            startActivity(intent)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面进行详解</p><p>step1：进行权限判断，判断用户是否已经给过我们授权了，使用函数<code>ContextCompat.checkSelfPermission()</code>函数</p><blockquote><p><code>ContextCompat.checkSelfPermission()</code>函数声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">checkSelfPermission</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> String permission)</span></span><br></pre></td></tr></table></figure><p>第一个参数：Context</p><p>第二个参数：具体权限名（Manifest的内部<code>permission</code>中有安卓所以权限字符串得的常量，可以直接调用）</p></blockquote><blockquote><p>PackageManager类中<br>静态常量<code>PERMISSION_GRANTED</code>表示已授权<br>静态常量<code>PERMISSION_DENIED</code>表示已拒绝</p></blockquote><p>step2：如果未申请权限，则进行<strong>权限申请</strong>，使用函数<code>ActivityCompat.requestPermissions()</code>函数</p><blockquote><p><code>ActivityCompat.requestPermissions()</code>函数声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">requestPermissions</span><span class="params">(<span class="keyword">final</span> <span class="meta">@NonNull</span> Activity activity,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> <span class="meta">@NonNull</span> String[] permissions, </span></span><br><span class="line"><span class="params"><span class="keyword">final</span> <span class="meta">@IntRange(from = 0)</span> <span class="type">int</span> requestCode)</span></span><br></pre></td></tr></table></figure><p>第一个参数：是Activity实例</p><p>第二个参数：一个String数组，把要申请的权限名放入数组中</p><p>第三个参数：权限申请的请求码</p></blockquote><p>step3：结果处理</p><p>调用完ActivityCompat.requestPermission()函数后会进入<code>onRequestPermissionsResult()</code>回调函数中，授权的结果会封装在grantResults中</p><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p>为什么查询是否有某个权限使用的是ContextCompat，而申请权限使用的是ActivityCompat</p><p><strong><code>ContextCompat</code></strong>：主要提供与 <code>Context</code> 相关操作的兼容性方法，重点在于与上下文相关的通用操作，它不具备像 <code>Activity</code> 那样与用户直接交互的能力</p><p><strong><code>ActivityCompat</code></strong>：专注于与 <code>Activity</code> 相关的兼容性操作，权限请求是一个与用户交互的过程，需要一个Activity 来显示系统提供的权限请求对话框</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓四大件</title>
      <link href="/2025/03/10/%E5%AE%89%E5%8D%93%E5%9B%9B%E5%A4%A7%E4%BB%B6/"/>
      <url>/2025/03/10/%E5%AE%89%E5%8D%93%E5%9B%9B%E5%A4%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="活动-Activity"><a href="#活动-Activity" class="headerlink" title="活动(Activity)"></a>活动(Activity)</h1><p>忘记写了笔记了，有时间再补</p><h1 id="广播-BroadcastReceiver"><a href="#广播-BroadcastReceiver" class="headerlink" title="广播(BroadcastReceiver)"></a>广播(BroadcastReceiver)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><p>标准广播：完全异步，所有的BroadcastReceiver几乎会在同一时刻收到该条广播，不可截断</p></li><li><p>有序广播：同步执行，同一时刻只会有一个BroadcastReceiver接收到，可以选择是否截断</p></li></ul><h2 id="更多系统广播消息"><a href="#更多系统广播消息" class="headerlink" title="更多系统广播消息"></a>更多系统广播消息</h2><p><Android SDK>\platforms&lt;Android api版本&gt;\data\broadcast_actions.txt</p><h2 id="注册BroadcastReceiver"><a href="#注册BroadcastReceiver" class="headerlink" title="注册BroadcastReceiver"></a>注册BroadcastReceiver</h2><p>分类：静态注册（在AndroidManifest.xml中注册），动态注册（在代码中注册）</p><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><ol><li>新建一个类，继承<code>BroadcastReceiver</code>类，重写父类<code>onReceiver()</code></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">TimeChangeReceiver</span> : <span class="type">BroadcastReceiver</span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(p0: <span class="type">Context</span>?, p1: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        Toast.makeText(p0,<span class="string">&quot;时间改变了&quot;</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>创建意图过滤器<code>IntentFilter</code>,并添加需要过滤出来的活动</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个意图过滤器</span></span><br><span class="line"><span class="keyword">val</span> intentFilter = IntentFilter()</span><br><span class="line">intentFilter.addAction(<span class="string">&quot;android.intent.action.TIME_TICK&quot;</span>)</span><br><span class="line">timeChangeReceiver = TimeChangeReceiver()</span><br></pre></td></tr></table></figure></li><li><p>注册过滤器</p></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册Receiver</span></span><br><span class="line">registerReceiver(timeChangeReceiver,intentFilter)</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 动态注册的BroadcastReceiver要取消注册</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        unregisterReceiver(timeChangeReceiver)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态注册-实现开机启动"><a href="#静态注册-实现开机启动" class="headerlink" title="静态注册 实现开机启动"></a>静态注册 实现开机启动</h3><p>如上，动态注册虽然很方便，但必须在程序启动之后才能接收到广播，因为注册的逻辑是在<code>onCreate()</code>中注册的</p><p>想要在程序未启动的时候也能接收到广播，这就需要动态注册了</p><blockquote><p>在很久之前，静态广播可以监听所有的系统广播，但由于大量恶意应用在未启动情况下监听系统广播，应用频繁启动，消耗手机性能。在Android8.0后，所有隐式广播(没有具体指定发送给哪个应用程序的广播)不允许使用静态注册的方式接收了</p></blockquote><ol><li>新建一个类，继承<code>BroadcastReceiver</code>类，重写父类<code>onReceiver()</code></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BootCompleteReceiver</span> : <span class="type">BroadcastReceiver</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">        Toast.makeText(context,<span class="string">&quot;开机完成&quot;</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在AndroidManifest.xml中注册</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.BootCompleteReceiver&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>enabled-&gt;表示是否启用</p><p>exported-&gt;表示是否允许这个BroadcastReceiver接收本程序以外的广播</p></blockquote><ol start="3"><li>为BroadcastReceiver设置<code>IntentFilter</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.BootCompleteReceiver&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h2><h3 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.example.broadcasttest.MY_BROADACST&quot;</span>)</span><br><span class="line">            intent.setPackage(packageName)</span><br><span class="line">            sendBroadcast(intent)</span><br></pre></td></tr></table></figure><ol><li>创建一个Intent对象，并把要发送的广播的值传入</li><li>调用Intent的<code>setPackage()</code>方法传入当前应用程序的包名</li><li>最后发送广播</li></ol><blockquote><p>这里的<code>setPackage()</code>是指定这条广播是发送给哪个应用程序的,在哪个应用程序里面传播，从而让这条广播成为一个显示广播，否则静态注册BroadcastReceiver无法接收</p></blockquote><p><strong>注意：</strong> 因为广播是靠Intent发送的，所以你也可以在Intent中携带一些数据</p><h3 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="发送有序广播"></a>发送有序广播</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.example.broadcasttest.MY_OrderedBROADACST&quot;</span>)</span><br><span class="line">            intent.setPackage(packageName)</span><br><span class="line">            sendOrderedBroadcast(intent,<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>和发送标准广播相似，只不过这里发送的是<code>sendOrderedBroadcast(intent,null)</code>,<br>第一个参数：Intent</p><p>第二个参数：一个与权限相关的字符串</p><h4 id="设置接收先后"><a href="#设置接收先后" class="headerlink" title="设置接收先后"></a>设置接收先后</h4><ul><li>动态注册</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intentFilter2 = IntentFilter()</span><br><span class="line">        intentFilter2.addAction(<span class="string">&quot;com.example.broadcasttest.MY_OrderedBROADACST&quot;</span>)</span><br><span class="line">        intentFilter2.priority = <span class="number">100</span></span><br><span class="line">        broadcastReceiver2=MyBroadcastReceiver2()</span><br><span class="line">        registerReceiver(broadcastReceiver2,intentFilter2)</span><br></pre></td></tr></table></figure><p>​<code>intentFilter2.priority</code>即设置优先级，优先级越高的BroadcastReceiver越先收到广播</p><ul><li>静态注册</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;.MyBroadcastReceiver2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.broadcasttest.MY_OrderedBROADACST&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="截断广播"><a href="#截断广播" class="headerlink" title="截断广播"></a>截断广播</h4><p>在优先级高的Receiver中调用 <code>abortBroadcast()</code>函数即可截断广播</p><h1 id="内容提供者-ContentProvider"><a href="#内容提供者-ContentProvider" class="headerlink" title="内容提供者(ContentProvider)"></a>内容提供者(ContentProvider)</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin基础</title>
      <link href="/2025/03/05/Kotlin%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/03/05/Kotlin%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin基础"><a href="#Kotlin基础" class="headerlink" title="Kotlin基础"></a>Kotlin基础</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 <span class="function"><span class="keyword">fun</span> 函数名称<span class="params">([函数参数...])</span></span>: 返回值类型 &#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高阶函数与lambda表达式，匿名函数，闭包"><a href="#高阶函数与lambda表达式，匿名函数，闭包" class="headerlink" title="高阶函数与lambda表达式，匿名函数，闭包"></a>高阶函数与lambda表达式，匿名函数，闭包</h3><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><blockquote><ul><li><p>高阶函数：如果一个函数接收另一个函数作为参数，或者返回值的类型就是一个函数，那么该函数称为高阶函数</p></li><li><p>函数可以被存储在变量中，可以作为参数传递给其他高阶函数并从中返回，就想使用普通变量一样</p><p>类型，例如：以一个String为参数，空返回值的函数的类型：(String) -&gt; Unit</p></li></ul></blockquote><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><blockquote><p>匿名函数有类型，匿名函数可以当作变量 赋值给 函数类型变量</p><p>函数的类型由传入的参数和返回值类型决定。例如：以一个String为参数，空返回值（Unit）的函数的类型：(String) -&gt; Unit</p><p>lambda表达式是给函数变量赋值的一种方式，也可以用 匿名函数（<code>fun</code> 关键字定义）</p></blockquote><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">val</span> lambdaName: (参数类型) -&gt; 返回类型 = &#123; 参数名: 参数类型 -&gt; 函数体 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>lambda表达式不需要return来返回数据，他会隐式<strong>自动返回函数体最后一行的结果</strong></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量的类型是一个匿名函数(类型：()-&gt;String)</span></span><br><span class="line"><span class="keyword">val</span> func :()-&gt;String</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值一个匿名函数,和具名函数不同，lambda表达式不需要return来返回数据，他会隐式自动返回函数体最后一行的结果</span></span><br><span class="line">func = &#123;</span><br><span class="line">    <span class="keyword">val</span> name= <span class="string">&quot;姓名&quot;</span></span><br><span class="line">    <span class="string">&quot;你好，<span class="subst">$&#123;name&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当lambda有一个参数时，用<code>it</code>代替。当lambda有多个参数时，需要把参数名放在函数定义中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> func:(String)-&gt;<span class="built_in">Boolean</span> = &#123;name -&gt;<span class="comment">//这个name就是参数名（String）</span></span><br><span class="line">                             </span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure><ul><li>因为 在 Kotlin 的 Lambda 表达式里，<strong><code>return</code> 默认会终止最外层的函数，而不是只返回 Lambda 的值！（非局部返回（non-local return））</strong>，所以在Lambda中没有办法直接使用return语句返回结果</li><li>如果你只想让 Lambda 自己返回，而不是终止外层函数，那就需要用<strong>标签返回（label return）</strong></li></ul><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>用<code>inline</code>关键字标记的函数</p><h3 id="中缀函数"><a href="#中缀函数" class="headerlink" title="中缀函数"></a>中缀函数</h3><p>用<code>infix</code>关键字标记的函数被称为中缀函数，在使用时，可以省略调用的点和括号进行调用，infix函数必须满足以下要求：</p><ul><li>必须是成员函数。</li><li>只能有一个参数。</li><li>参数不能有默认值。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(string: <span class="type">String</span>)</span></span>: String&#123;</span><br><span class="line">        <span class="keyword">return</span> name+string</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">student test <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure><ul><li>注：中缀函数调用的优先级低于算术运算符、类型转换和<code>rangeTo</code>运算符</li></ul><h2 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h2><h3 id="类的创建，使用"><a href="#类的创建，使用" class="headerlink" title="类的创建，使用"></a>类的创建，使用</h3><p>Kotlin中的类可以添加一个<strong>主构造函数</strong>和一个或多个<strong>次要构造函数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类的定义 + 主构造函数(主构造函数是类定义的一部分)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">constructor</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> (name: String ,age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name :String = name</span><br><span class="line">    <span class="keyword">get</span>() &#123;<span class="keyword">return</span> field&#125;</span><br><span class="line">        <span class="keyword">set</span>(value)&#123;field = value&#125;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = age</span><br><span class="line">        <span class="keyword">get</span>() &#123;<span class="keyword">return</span> field&#125;</span><br><span class="line">        <span class="keyword">set</span>(value)&#123;field = value&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不希望这些属性在一开始就有初始值，而是之后某一个时刻去设定初始值，我们也可以为其添加懒加载(lateinit )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">次构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String,<span class="keyword">var</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String):<span class="keyword">this</span>(name,<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主构造函数可以加var或者val，但次构造函数不可</p><p>次构造函数需要调用其他构造函数（可以是主构造函数，也可以是次构造函数），但是调用链<strong>最终要调用主构造函数</strong></p></blockquote><p>因此，主构造函数相比次要（辅助）构造函数：</p><ul><li><strong>主构造函数：</strong> 可以直接在主构造函数中定义类属性，使用更方便，但是主构造函数只能存在一个，并且无法编写函数体，只有为类属性做初始化赋值的效果。</li><li><strong>辅助（次要）构造函数：</strong> 可以存在多个，并且可以自定义函数体，但是无法像主构造函数那样定义类属性，并且当类具有主构造函数时，所有次要构造函数必须直接或间接地调用主构造函数。</li></ul><h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><p>在对象创建时，我们可能需要做一些初始化工作，我们可以使用初始化代码块来完成</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">constructor</span>(<span class="keyword">var</span> name: String,<span class="keyword">var</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;初始化代价快&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String): <span class="keyword">this</span>(name,<span class="number">18</span>)&#123;</span><br><span class="line">        println(<span class="string">&quot;1 次构造函数&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(age: <span class="built_in">Int</span>):<span class="keyword">this</span>(<span class="string">&quot;小明&quot;</span>)&#123;</span><br><span class="line">        println(<span class="string">&quot;2 次构造函数&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;                                                                                                                                                  </span><br></pre></td></tr></table></figure><p><strong>对象初始化过程：</strong></p><p>调用辅助构造函数时：通过辅助构造函数调用主构造函数，主构造函数，init代码块，辅助构造函数代码块</p><h3 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h3><p>在类里面定义呗，和java没什么不同</p><h3 id="运算符重载（我是在学C-吗？）"><a href="#运算符重载（我是在学C-吗？）" class="headerlink" title="运算符重载（我是在学C++吗？）"></a>运算符重载（我是在学C++吗？）</h3><p>Kotlin支持为程序中已知的运算符集提供自定义实现，这些运算符具有固定的符号表示（如<code>+</code>或<code>*</code>）以及对应的优先级，要实现运算符重载，请为相应类型提供具有对应运算符指定名称的成员函数，而当前的类对象，则直接作为对应运算符左边的操作数（类比C++）</p><p><strong>operator关键字</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> (<span class="keyword">var</span> name: String ,<span class="keyword">var</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="comment">//比如我们希望两个学生对象相加，得到的结果为名字相加，年龄相加的一个新学生</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(another: <span class="type">Student</span>)</span></span>: Student&#123;</span><br><span class="line">        <span class="keyword">return</span> Student(<span class="keyword">this</span>.name+another.name,<span class="keyword">this</span>.age+another.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常见的一些运算符对应的函数名称"><a href="#常见的一些运算符对应的函数名称" class="headerlink" title="常见的一些运算符对应的函数名称"></a>常见的一些运算符对应的函数名称</h4><table><thead><tr><th>符号(一元运算符)</th><th>对应的函数名称</th></tr></thead><tbody><tr><td><code>+a</code></td><td><code>a.unaryPlus()</code></td></tr><tr><td><code>-a</code></td><td><code>a.unaryMinus()</code></td></tr><tr><td><code>!a</code></td><td><code>a.not()</code></td></tr><tr><td><code>a--</code></td><td><code>a.dec()</code></td></tr><tr><td><code>a++</code></td><td><code>a.inc()</code></td></tr></tbody></table><p><code>inc()</code>和<code>dec()</code>函数比较特殊，它们必须返回一个值，执行后应该得到一个新生成的对象，然后变量的值直接引用到这个新的对象</p><table><thead><tr><th>符号（二元运算符）</th><th>对应的函数名称</th></tr></thead><tbody><tr><td><code>a + b</code></td><td><code>a.plus(b)</code></td></tr><tr><td><code>a - b</code></td><td><code>a.minus(b)</code></td></tr><tr><td><code>a * b</code></td><td><code>a.times(b)</code></td></tr><tr><td><code>a / b</code></td><td><code>a.div(b)</code></td></tr><tr><td><code>a % b</code></td><td><code>a.rem(b)</code></td></tr><tr><td><code>a..b</code></td><td><code>a.rangeTo(b)</code></td></tr><tr><td><code>a..&lt;b</code></td><td><code>a.rangeUntil(b)</code></td></tr></tbody></table><table><thead><tr><th>符号(复合赋值运算符)</th><th>对应的函数名称</th></tr></thead><tbody><tr><td><code>a += b</code></td><td><code>a.plusAssign(b)</code></td></tr><tr><td><code>a -= b</code></td><td><code>a.minusAssign(b)</code></td></tr><tr><td><code>a *= b</code></td><td><code>a.timesAssign(b)</code></td></tr><tr><td><code>a /= b</code></td><td><code>a.divAssign(b)</code></td></tr><tr><td><code>a %= b</code></td><td><code>a.remAssign(b)</code></td></tr></tbody></table><table><thead><tr><th>符号(返回Boolean)</th><th>对应的函数名称</th></tr></thead><tbody><tr><td><code>a in b</code></td><td><code>b.contains(a)</code></td></tr><tr><td><code>a !in b</code></td><td><code>!b.contains(a)</code></td></tr></tbody></table><p>比较运算符只需要实现一个函数即可：</p><table><thead><tr><th>运算符</th><th>对应的函数名称</th></tr></thead><tbody><tr><td><code>a &gt; b</code></td><td><code>a.compareTo(b) &gt; 0</code></td></tr><tr><td><code>a &lt; b</code></td><td><code>a.compareTo(b) &lt; 0</code></td></tr><tr><td><code>a &gt;= b</code></td><td><code>a.compareTo(b) &gt;= 0</code></td></tr><tr><td><code>a &lt;= b</code></td><td><code>a.compareTo(b) &lt;= 0</code></td></tr></tbody></table><p> 函数调用运算符重载</p><table><thead><tr><th>运算符</th><th>对应的函数名称</th></tr></thead><tbody><tr><td><code>a()</code></td><td><code>a.invoke()</code></td></tr></tbody></table><table><thead><tr><th>运算符</th><th>对应的函数名称</th></tr></thead><tbody><tr><td><code>a[i]</code></td><td><code>a.get(i)</code></td></tr></tbody></table><h3 id="中缀函数-1"><a href="#中缀函数-1" class="headerlink" title="中缀函数"></a>中缀函数</h3><p>用<code>infix</code>关键字标记的函数被称为中缀函数，在使用时，可以省略调用的点和括号进行调用，infix函数必须满足以下要求：</p><ul><li>必须是成员函数。</li><li>只能有一个参数。</li><li>参数不能有默认值。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(string: <span class="type">String</span>)</span></span>: String&#123;</span><br><span class="line">        <span class="keyword">return</span> name+string</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">student test <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure><ul><li>注：中缀函数调用的优先级低于算术运算符、类型转换和<code>rangeTo</code>运算符</li></ul><h3 id="空值和-可-空类型"><a href="#空值和-可-空类型" class="headerlink" title="空值和(可)空类型"></a>空值和(可)空类型</h3><p>所有的类型默认都是<strong>非空类型</strong>，非空类型的变量是不允许被赋值为null的</p><p>如果我们希望某个变量在初始情况下使用<code>null</code>而不去引用某一个具体对象，该怎么做呢，此时我们需要将变量的类型修改为<strong>可空类型</strong>，只需在类型名称的后面添加一个<code>?</code></p><p>在调用的时候用if判断</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student: Student? =<span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (student != <span class="literal">null</span>)&#123;</span><br><span class="line">        student.age</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果不想用if包裹</p><blockquote><ul><li><p>如果我们很明确知道这个可空类型一定不为空可以使用<strong>非空断言操作符（<code>!!</code>）</strong></p><p>例如：<code>student!!.age</code>调用</p></li><li><p>也可以使用<strong>安全调用运算符（<code>?.</code>）</strong>，如果对象为空则返回null</p><p>例如：<code>student?.age</code></p></li><li><p>不过在有些时候，可能我们希望如果变量为null，在使用安全调用运算符时，返回一个我们自定义的结果，而不是null，则可以使用<strong>空合并操作符?：</strong></p><p>例如：student?.age ?: “自定义结果”</p></li></ul></blockquote><h3 id="空合并操作符"><a href="#空合并操作符" class="headerlink" title="空合并操作符?:"></a>空合并操作符?:</h3><p>?:操作符的意思是，如果左边的求值结果为null，就使用右侧的结果值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">student?.age ?: <span class="string">&quot;自定义结果&quot;</span>  </span><br></pre></td></tr></table></figure><h3 id="解构声明"><a href="#解构声明" class="headerlink" title="解构声明"></a>解构声明</h3><blockquote><p>允许你将一个对象分解为多个变量</p></blockquote><p>要让一个类的属性支持解构，我们只需添加约定的函数即可，在Kotlin中，我们可以自定义解构出来的结果，而具体如何获取，需要定义一个<strong>componentN</strong>函数并通过返回值的形式返回解构的结果</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span> = name   <span class="comment">//使用component1表示解构出来的第一个参数</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span> = age    <span class="comment">//使用component2表示解构出来的第二个参数</span></span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> component3...  //以此类推</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">val</span> s1 = Student(<span class="string">&quot;小明&quot;</span>,<span class="number">18</span>)</span><br><span class="line"><span class="keyword">val</span>(name , age) = s1</span><br><span class="line"><span class="comment">//此时name=&quot;小明&quot; 、age=18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="权限控制（和java有些不同）"><a href="#权限控制（和java有些不同）" class="headerlink" title="权限控制（和java有些不同）"></a>权限控制（和java有些不同）</h3><p>在类、对象、接口、构造函数和函数，以及属性上，可以为其添加 <em>可见性修饰符</em> 来控制其可见性</p><p><strong>public</strong>、<strong>protected</strong>、<strong>internal</strong>、<strong>private</strong>、</p><ol><li><code>public</code> : 公开，可见性最大，哪里都可以引用</li><li><code>private</code>: 私有，可见性最小</li><li><code>protected</code>: 保护，相当于<code>private</code> + 子类可见(不可以用做顶级声明，只能用作类成员)</li><li><code>internal</code>: 内部，仅对module可见</li></ol><h2 id="封装继承多态"><a href="#封装继承多态" class="headerlink" title="封装继承多态"></a>封装继承多态</h2><blockquote><ul><li>封装，把对象的属性和函数结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。</li><li>继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和函数，并根据实际需求扩展出新的行为。</li><li>多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的函数</li></ul></blockquote><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote><p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员—–成员私有化</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>在 Kotlin 中，类是默认 <strong>final（终态）</strong> 的，也就是说，除非显式声明为 <code>open</code></li><li>单继承</li><li>继承时需要调用父类的构造函数，完成对父类属性的初始化（子类必须初始化父类属性），如果父类只有次构造函数，子类必须在自己的次构造函数中使用 <code>super</code> 显式调用父类的构造函数。</li><li>先完成父类的构造，再完成之类的构造</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承语法：</span></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">protected</span> <span class="keyword">var</span> name: String, <span class="keyword">protected</span> <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="comment">//调用父类的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArtStudent</span>(name: String, age: <span class="built_in">Int</span>, <span class="keyword">protected</span> <span class="keyword">val</span> school: String) : Student(name, age) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为<code>private</code>，那么子类将无法访问（但是依然是继承了这个属性的）</p></blockquote><h3 id="方法与属性的重写"><a href="#方法与属性的重写" class="headerlink" title="方法与属性的重写"></a>方法与属性的重写</h3><ol><li><p>父类的成员需要用 <code>open</code> 修饰。</p></li><li><p>子类中用 <code>override</code> 关键字实现重写</p></li></ol><blockquote><p>对于这些使用了<code>open</code>关键字的属性（函数、变量等）只要是在初始化函数、构造函数中使用，IDEA都会给出警告</p></blockquote><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>向上转型： 直接强制转型就好了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> artStudent: Student = ArtStudent()</span><br></pre></td></tr></table></figure><p>向下转型：<strong>as</strong>关键字强转</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(student: <span class="type">Student</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> artStudent: ArtStudent = student <span class="keyword">as</span> ArtStudent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Any类"><a href="#Any类" class="headerlink" title="Any类"></a>Any类</h3><p>Kotlin类层次结构的根。每个Kotlin类都有 Any 作为超类</p><h4 id="运算符重载equals"><a href="#运算符重载equals" class="headerlink" title="运算符重载equals"></a>运算符重载equals</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure><ul><li><em>结果上</em> 相等 (<code>==</code> 等价于 <code>equals()</code>)</li><li><em>引用上</em> 相等 (<code>===</code> 判断两个变量是否都是引用的同一个对象)</li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>我们设计的类可能仅仅是作为给其他类继承使用的类，而其本身并不需要创建任何实例对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用abstract表示这个是一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> type: String  <span class="comment">//抽象类中可以存在抽象成员属性</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span>   <span class="comment">//抽象类中可以存在抽象函数</span></span><br><span class="line">  <span class="comment">//注意抽象的属性不能为private，不然子类就没法重写了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个子类继承自抽象类时，必须要<strong>重写</strong>抽象类中定义的抽象属性和抽象函数：</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口一般只代表某些功能的抽象，接口包含了一系列内容的定义，类可以实现这个接口，表示类支持接口代表的功能。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x: String  <span class="comment">//接口中所有属性默认都是abstract的（可省略关键字）</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sleep</span><span class="params">()</span></span>   <span class="comment">//接口中所有函数默认都是abstract的（可省略关键字），也可以带有默认实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">game</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="type">A</span>, <span class="type">B</span> &#123;   <span class="comment">//接口的实现与类的继承一样，直接写到后面，多个接口用逗号隔开</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: String = <span class="string">&quot;测试&quot;</span>   <span class="comment">//跟抽象类一样，接口中的内容是必须要实现的</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sleep</span><span class="params">()</span></span> = println(<span class="string">&quot;管他什么早八不早八的，睡舒服再说&quot;</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">game</span><span class="params">()</span></span> = println(<span class="string">&quot;读大学就该玩游戏玩到爽&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中声明的属性可以是抽象的，也可以为Getter提供默认实现。在接口中声明的属性无法使用<code>field</code>后背字段，因此在接口中声明的Setter无法使用<code>field</code>进行赋值</p><h3 id="类的扩展"><a href="#类的扩展" class="headerlink" title="类的扩展"></a>类的扩展</h3><p>为某个类添加一些额外的函数或是属性，我们只需要通过一个被称为<em>扩展</em>的特殊声明来完成</p><p>比如我们想为String类型添加一个自定义的操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为官方的String类添加一个新的test函数，使其返回自定义内容</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">test</span><span class="params">()</span></span> = <span class="string">&quot;666&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> text = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    println(text.test())  <span class="comment">//就好像String类中真的有这个函数一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="当扩展函数作为参数赋值给变量时"><a href="#当扩展函数作为参数赋值给变量时" class="headerlink" title="当扩展函数作为参数赋值给变量时"></a>当扩展函数作为参数赋值给变量时</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//因为是对String类型的扩展函数，需要String.前缀</span></span><br><span class="line">    <span class="keyword">val</span> func: String.() -&gt; <span class="built_in">Int</span> = &#123;</span><br><span class="line">        <span class="keyword">this</span>.length   <span class="comment">//跟上面一样，扩展函数中的this依然指的是被扩展的类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;sahda&quot;</span>.func())  <span class="comment">//可以直接对符合类型的对象使用这个函数</span></span><br><span class="line">  func(<span class="string">&quot;Hello&quot;</span>)  <span class="comment">//如果是直接调用，那么必须要传入对应类型的对象作为首个参数，此时this就指向我们传入的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Kotlin进阶"><a href="#Kotlin进阶" class="headerlink" title="Kotlin进阶"></a>Kotlin进阶</h1><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型，（只是声明有这个临时数据类型）</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>类，接口，抽象类都支持泛型操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">var</span> name: String, <span class="keyword">var</span> value: T)</span><br><span class="line"><span class="comment">//这里的T就是一个待定的类型，同样是这个类具有的，我们称为泛型参数</span></span><br><span class="line"><span class="comment">//T相当于一个临时类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">var</span> score = Score&lt;<span class="built_in">Int</span>&gt;(<span class="string">&quot;小明&quot;</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><blockquote><ul><li>如果在编译阶段能够确定泛型的具体类型，也可以不用<Int>，自动推断</li><li>泛型类型在类内部使用时，由于无法确定具体类型，也只能当做<code>Any?</code>类去使用</li><li>泛型类型在类内部使用时，不能通过这个不确定的类型变量就去直接创建对象</li></ul></blockquote><h4 id="有关泛型的继承问题"><a href="#有关泛型的继承问题" class="headerlink" title="有关泛型的继承问题"></a>有关泛型的继承问题</h4><p>子类在继承时，可以选择将父类的泛型参数给明确为某一类型，或是使用子类定义的泛型参数作为父类泛型参数的实参使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">T</span>&gt;()&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>:T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类在继承时，可以选择将父类的泛型参数给明确为某一类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>():A&lt;String&gt;()&#123;<span class="comment">//子类直接明确为String类型</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>: String =<span class="string">&quot;Hello&quot;</span><span class="comment">//明确后所有用到泛型的地方都要变成具体类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//或是子类也是泛型,子类定义的泛型参数作为父类泛型参数的实参使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;<span class="type">D</span>&gt;():A&lt;D&gt;()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>: D &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; test(t: T): T = t</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test</span><span class="params">(func: (<span class="type">Int</span>) -&gt; <span class="type">T</span>)</span></span> : T&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test</span><span class="params">(T.()</span></span> -&gt; <span class="built_in">Unit</span>)&#123;<span class="comment">////甚至还可以是T类型的扩展函数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方高阶扩展函数"><a href="#官方高阶扩展函数" class="headerlink" title="官方高阶扩展函数"></a>官方高阶扩展函数</h3><h4 id="Any-apply-函数"><a href="#Any-apply-函数" class="headerlink" title="Any.apply()函数"></a>Any.apply()函数</h4><p>它可以让你在一个对象上执行一系列操作，同时保持代码的简洁性和可读性。它常用于对象的初始化和配置，以及链式调用</p><ul><li><code>apply()</code> 函数最终会返回调用它的对象本身。</li></ul><p>在匿名函数中处理<strong>调用apply()的对象</strong>，并返回对象本身</p><h4 id="Any-let-函数"><a href="#Any-let-函数" class="headerlink" title="Any.let()函数"></a>Any.let()函数</h4><p><code>let</code>：用于执行一个lambda表达式并将得到一个<strong>新的类型</strong>值并作为结果返回</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对当前对象进行操作，得到一个新的类型值并作为结果返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)  <span class="comment">//调用我们传入的函数，并将结果作为let返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Any-also-函数"><a href="#Any-also-函数" class="headerlink" title="Any.also()函数"></a>Any.also()函数</h4><p><code>also</code>：用于执行一个lambda表达式并返回对象本身，跟apply功能一致像，但是采用的是<code>it</code>参数形式传递给Lambda当前对象，而apply是采用this(扩展函数)的方式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对当前对象进行操作，并返回当前对象本身</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    ...</span><br><span class="line">    block(<span class="keyword">this</span>)   <span class="comment">//调用我们传入的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>   <span class="comment">//返回当前T类型对象本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Any-run-函数"><a href="#Any-run-函数" class="headerlink" title="Any.run()函数"></a>Any.run()函数</h4><p>用于执行一个lambda表达式并将得到的结果作为返回值返回，它跟let一样，使用this传递当前对象，可以看到接受的参数是一个扩展函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Any.apply()和Any.run()底层是靠传入的函数是<strong>扩展函数</strong>实现的</p><p>Any.also() 和 Any.let()底层是考 传入的函数是<strong>普通匿名</strong>函数实现的</p><p>Any.apply()与Any.also()，和Any.run()与 Any.let()实现的功能相近，只是底层不一样</p><h4 id="Any-takeIf-函数与Any-takeUnless-函数"><a href="#Any-takeIf-函数与Any-takeUnless-函数" class="headerlink" title="Any.takeIf()函数与Any.takeUnless()函数"></a>Any.takeIf()函数与Any.takeUnless()函数</h4><ul><li>takeIf()函数：传入一个判断表达式，如果表达式为true则返回调用者，为false则返回null</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeIf</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>takeUnless()函数：与takeIf()相反</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeIf</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (!predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协变、逆变、抗变"><a href="#协变、逆变、抗变" class="headerlink" title="*协变、逆变、抗变"></a>*协变、逆变、抗变</h3><p>泛型类型参数的默认情况下，泛型参数是 <strong>不变的（Invariant）</strong>。这意味着如果 <code>B</code> 是 <code>A</code> 的子类型，那么 <code>Box&lt;B&gt;</code> 并不是 <code>Box&lt;A&gt;</code> 的子类型</p><p>如果 <code>B</code> 是 <code>A</code> 的子类型，正常情况下只能子类转换为父类，泛型类型<code>Test&lt;T&gt;</code>存在以下几种形变：</p><ul><li>协变 (Covariance)：因为B是A的子类，所以<code>Test&lt;B&gt;</code>同样是<code>Test&lt;A&gt;</code>的子类，可以直接转换</li><li>逆变(Contravariance)：跟上面相反，<code>Test&lt;A&gt;</code>可以直接转换为<code>Test&lt;B&gt;</code>，前者是后者的子类</li><li>抗变 (Invariant)：<code>Test&lt;B&gt;</code>跟<code>Test&lt;A&gt;</code>没半毛钱关系，无法互相转换</li></ul><p>Kotlin中泛型类型参数默认是抗变的</p><p>但是实际上我们需要的可能是协变或是逆变，为了处理这种情况，Kotlin提供了两个关键字供我们使用：</p><ul><li><code>out</code> 关键字用于标记一个类型参数作为协变，可以实现子类到父类的转换。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> test1: Test&lt;<span class="built_in">Int</span>&gt; = Test(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> test2: Test&lt;<span class="keyword">out</span> Number&gt; = test1<span class="comment">//协变</span></span><br><span class="line"><span class="comment">//这里的out Number 相当于java中的 ? extends Number</span></span><br></pre></td></tr></table></figure><p>​out Number 代表 Number所有的子类</p><p>​协变类型在使用时会变成上界，因为无论子类是什么，都是继承自上界类型的，所以类型默认为上界</p><ul><li><code>in</code> 关键字用于标记一个类型参数作为逆变，可以实现父类到子类的转换。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> test: Test&lt;Any&gt; = Test(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> test2: Test&lt;<span class="keyword">in</span> <span class="built_in">Int</span>&gt; = test</span><br></pre></td></tr></table></figure><p>​in umber 代表Number所有的父类</p><p>​逆变类型在使用时由于没有上界，具体使用哪个父类也不清楚，所以只能是Any?类型了</p><blockquote><p>注意：因为协变后赋值属性会导致BUG，所以Kotlin对于out或in的类型进行了限制</p><p>因此，对于in和out来说，协变和逆变的属性将其限制为了生产者和消费者：</p><ul><li>使用<code>out</code>修饰的泛型不能用作函数的参数，对应类型的成员变量setter也会被限制，只能当做一个生产者（仅用于输出）使用。</li><li>使用<code>in</code>修饰的泛型不能用作函数的返回值，对应类型的成员变量getter也会被限制，只能当做一个消费者（仅用于输入）使用。</li></ul></blockquote><h3 id="通配符（-）"><a href="#通配符（-）" class="headerlink" title="通配符（*）"></a>通配符（*）</h3><p>在有些时候，我们可能并不在乎到底使用哪一个类型，我们希望一个变量可以接受任意类型的结果，而不是去定义某一个特定的上界或下界。在Kotlin泛型中，星号（<code>*</code>）可以代表任意类型，由于不确定具体类型，使用时只能是Any?类型</p><h3 id="泛型界限"><a href="#泛型界限" class="headerlink" title="*泛型界限"></a>*泛型界限</h3><h4 id="定义上界"><a href="#定义上界" class="headerlink" title="定义上界"></a>定义上界</h4><ul><li>单个上界</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设定类型参数上界，必须是Number或是Number的子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>&lt;<span class="type">T : Number</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> name: String, <span class="keyword">val</span> value: T)</span><br></pre></td></tr></table></figure><p>使用类似于继承的语法来完成类型的上界限制，定义后，使用的时候具体类型只能是我们指定的上界类型或其子类</p><p>默认不指定时，上界默认为<code>Any?</code></p><ul><li>多个上界（比如必须同时是某两个类型的子类（或接口实现））</li></ul><p>使用<code>where</code>关键字</p><p>例如：需要同时是Number的子类，同时要实现Comparable接口</p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="*类型擦除"></a>*类型擦除</h3><p>泛型的类型检查仅仅只存在于编译阶段，在源代码编译之后，实际上并不会保留任何关于泛型的内容，这就是<strong>泛型擦除</strong></p><p>例如：擦除前</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">data</span>: T) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(t: <span class="type">T</span>)</span></span> : T &#123;</span><br><span class="line">        <span class="keyword">val</span> tmp = <span class="keyword">data</span></span><br><span class="line">        <span class="keyword">data</span> = t</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>擦除后(泛型类型全变成了Any?)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>(<span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">data</span>: Any?)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(t: <span class="type">Any</span>?)</span></span>: Any?&#123;</span><br><span class="line">        <span class="keyword">val</span> temp = <span class="keyword">data</span></span><br><span class="line">        <span class="keyword">data</span> = t</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>如果存在上界，那么擦除后会是上界的类型</p></blockquote><p>由于运行时不存在泛型的概念，因此，很多操作都是不允许的，比如类型判断</p><h4 id="内联泛型函数的类型擦除"><a href="#内联泛型函数的类型擦除" class="headerlink" title="内联泛型函数的类型擦除"></a>内联泛型函数的类型擦除</h4><p>内联函数，泛型擦除的处理会有一些不同。内联函数的代码是在编译时期直接插入到调用处的，在编译之后具体类型必须要存在，否则会出现问题（因为类型可以明确）因此其泛型参数的具体类型信息是可用的</p><p><strong>类型信息在调用处保留</strong></p><p><strong>使用关键字<code>reified</code>可具化类型参数,进行类型检查和类型转换</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加reified关键字具化类型参数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">isType</span><span class="params">(value: <span class="type">Any</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value <span class="keyword">is</span> T  <span class="comment">//这样就可以在函数里面使用这个类型了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(isType&lt;String&gt;(<span class="string">&quot;666&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ol><li>使用官方预设函数（<code>arrayOf()</code>、<code>arrayOfNulls()</code>、<code>emptyArray()</code>）</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arra: Array&lt;<span class="built_in">Int</span>&gt; = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>使用类<code>Array</code>构造函数创建。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * size: 数组的大小</span></span><br><span class="line"><span class="comment"> * init: (Int) -&gt; T: 初始化操作，这个操作会根据数组大小，循环调用传入的函数size次，并且将对应的下标作为参数，我们需要在函数中返回当前数组元素类型的结果，这样就会自动填充到数组的对应位置上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">constructor</span>(size: <span class="built_in">Int</span>, <span class="keyword">init</span>: (<span class="built_in">Int</span>) -&gt; T)</span><br></pre></td></tr></table></figure><p>Array类的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">//构造函数，包括数组大小、元素初始化函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">constructor</span>(size: <span class="built_in">Int</span>, <span class="keyword">init</span>: (<span class="built_in">Int</span>) -&gt; T)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载[]运算符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前数组大小（可以看到是val类型的，一旦确定不可修改）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代运算重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 数组在创建完成之后，数组容量和元素类型是固定不变的，后续无法进行修改。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array: Array&lt;<span class="built_in">Int</span>&gt; = arrayof(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(element <span class="keyword">in</span> array)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取到对应索引</span></span><br><span class="line"><span class="keyword">for</span>(index <span class="keyword">in</span> array.indices)&#123;</span><br><span class="line">    println(array[index])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时遍历索引和元素本身，也可以使用withIndex函数</span></span><br><span class="line"><span class="keyword">for</span> ((index,element) <span class="keyword">in</span> array.withIndex())&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用Lambda表达式形式</span></span><br><span class="line"><span class="comment">//Lambda遍历索引,和元素</span></span><br><span class="line">array.forEachIndexed &#123; index, i -&gt;println(<span class="string">&quot;元素<span class="variable">$i</span> ,位置<span class="variable">$index</span>&quot;</span>)&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Lambda遍历元素</span></span><br><span class="line">array.forEach &#123; println(<span class="string">&quot;元素值:<span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;out T&gt;</span>.<span class="title">joinToString</span><span class="params">(separator: <span class="type">CharSequence</span> = <span class="string">&quot;, &quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                         , prefix: <span class="type">CharSequence</span> = <span class="string">&quot;&quot;</span>, postfix: <span class="type">CharSequence</span> = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                         , limit: <span class="type">Int</span> = <span class="number">-1</span>, truncated: <span class="type">CharSequence</span> = <span class="string">&quot;...&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                         , transform: ((<span class="type">T</span>) -&gt; <span class="type">CharSequence</span>)? = <span class="literal">null</span>)</span></span></span><br><span class="line">: String &#123;</span><br><span class="line">    <span class="keyword">return</span> joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>separator</code>: 分隔符</p><p><code>prefix</code>: 前缀</p><p><code>postfix</code>: 后缀</p><p><code>limit</code>: 显示几个元素</p><p><code>truncated</code>: 当元素数量超过 <code>limit</code> 时，用于表示截断部分的字符串</p><p><code>transform</code>一个可选的转换函数，用于将数组中的每个元素 <code>T</code> 转换为 <code>CharSequence</code> 类型</p><h4 id="比较两个数组"><a href="#比较两个数组" class="headerlink" title="比较两个数组"></a>比较两个数组</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从内容上比较2个函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">inline</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;out T&gt;</span>?.<span class="title">contentEquals</span><span class="params">(other: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;?)</span></span>: <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure><h4 id="拷贝数组"><a href="#拷贝数组" class="headerlink" title="拷贝数组"></a>拷贝数组</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;T&gt;</span>.<span class="title">copyOf</span><span class="params">()</span></span>: Array&lt;T&gt;<span class="comment">//完整拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;T&gt;</span>.<span class="title">copyOf</span><span class="params">(newSize: <span class="type">Int</span>)</span></span>: Array&lt;T?&gt;<span class="comment">//新数组的长度，扩容则多的填充null </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;T&gt;</span>.<span class="title">copyOfRange</span><span class="params">(fromIndex: <span class="type">Int</span>, toIndex: <span class="type">Int</span>)</span></span>: Array&lt;T&gt;<span class="comment">//拷贝范围的数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;T&gt;</span>.<span class="title">sliceArray</span><span class="params">(indices: <span class="type">IntRange</span>)</span></span>: Array&lt;T&gt;<span class="comment">///拷贝范围的数组</span></span><br></pre></td></tr></table></figure><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array&lt;<span class="keyword">out</span> T&gt;.contains(element: T): <span class="built_in">Boolean</span><span class="comment">//查询数组是否包含element</span></span><br><span class="line"></span><br><span class="line">element <span class="keyword">in</span> array<span class="comment">//就相当于上面</span></span><br><span class="line"></span><br><span class="line">Array&lt;<span class="keyword">out</span> T&gt;.indexOf(element: T): <span class="built_in">Int</span><span class="comment">//返回索引</span></span><br><span class="line">Array&lt;<span class="keyword">out</span> T&gt;.binarySearch(element: T, fromIndex: <span class="built_in">Int</span> = <span class="number">0</span>, toIndex: <span class="built_in">Int</span> = size)<span class="comment">//二分搜索（必须是有序的）</span></span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; Array<span class="type">&lt;out T&gt;</span>.<span class="title">sort</span><span class="params">()</span></span>: <span class="built_in">Unit</span><span class="comment">//默认升序</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; Array<span class="type">&lt;out T&gt;</span>.<span class="title">sortDescending</span><span class="params">()</span></span>: <span class="built_in">Unit</span><span class="comment">//降序</span></span><br></pre></td></tr></table></figure><p>如果要用sort函数则首先类型需要实现Comparable接口</p><p><em>使用当前对象this和给定对象other进行比较，如果返回小于0的数，说明当前对象应该排在前面，反之排后面，返回0表示同样的级别</em></p><h3 id="可变长度参数，扩展运算符"><a href="#可变长度参数，扩展运算符" class="headerlink" title="可变长度参数，扩展运算符"></a>可变长度参数，扩展运算符</h3><p>关键字：<code>vararg</code></p><blockquote><ul><li>可变长度参数一般放在后面（fun test(a: String , vararg str: String)）</li><li>但是需要注意的事，可变长参数在函数的形参列表里面只能存在一个</li></ul></blockquote><p>在函数内部，可变长度参数为一个支持协变的数组</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(a:<span class="type">String</span>,<span class="keyword">vararg</span> str: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> array: Array&lt;<span class="keyword">out</span> String&gt; = str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>把数组作为参数给到一个可变长参数中,<strong>扩展运算符</strong>（<code>*</code>）此运算符将数组的每个元素作为单个参数传递</li></ul><h3 id="原生类型数组"><a href="#原生类型数组" class="headerlink" title="原生类型数组"></a>原生类型数组</h3><p><code>Array&lt;Int&gt;</code>、<code>Array&lt;Double&gt;</code>、<code>Array&lt;Char&gt;</code>等等，这些包含基本类型的数组往往在编译时可以得到优化（比如JVM平台会直接编译为基本类型数组，如<code>int[]</code>、<code>double[]</code>等，可以免去装箱拆箱开销）</p><table><thead><tr><th>原生类型数组</th><th>相当于Java</th></tr></thead><tbody><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean-array/"><code>BooleanArray</code></a></td><td><code>boolean[]</code></td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/"><code>ByteArray</code></a></td><td><code>byte[]</code></td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char-array/"><code>CharArray</code></a></td><td><code>char[]</code></td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/"><code>DoubleArray</code></a></td><td><code>double[]</code></td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float-array/"><code>FloatArray</code></a></td><td><code>float[]</code></td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int-array/"><code>IntArray</code></a></td><td><code>int[]</code></td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/"><code>LongArray</code></a></td><td><code>long[]</code></td></tr><tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short-array/"><code>ShortArray</code></a></td><td><code>short[]</code></td></tr></tbody></table><ul><li>创建原生类型数组：1. 构造函数   2. intArrayOf()</li></ul><blockquote><p>如果是基本数据类型的可变长度参数，则在函数中参数默认是原生类型数组</p></blockquote><h4 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="keyword">var</span> array = arrayOf(intArrayOf(<span class="number">1</span>, <span class="number">2</span>), intArrayOf(<span class="number">3</span>, <span class="number">4</span>), intArrayOf(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组构造函数法</span></span><br><span class="line"><span class="keyword">var</span> array = Array(<span class="number">3</span>, &#123; Array(<span class="number">2</span>) &#123; <span class="number">0</span> &#125; &#125;)</span><br><span class="line"><span class="comment">////&#123;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//更高维度同理</span></span><br></pre></td></tr></table></figure><p>多层比较可以用：<code>contentDeepEquals()</code></p><h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p>实现接口Collection</p><p><strong>List：</strong>  有序的集合，通过索引访问元素，可以包含重复元素</p><p><strong>Set：</strong>  不包含重复元素的集合，它更像是数学中的集合，一般情况下不维护元素顺序</p><p><strong>Map：</strong>  是一组键值对，其中每一个键不可重复存在，每个键都映射到恰好一个值（值可以重复存在）</p><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><h4 id="可变List集合MutableList"><a href="#可变List集合MutableList" class="headerlink" title="可变List集合MutableList"></a>可变List集合MutableList</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list: MutableList&lt;String&gt; = mutableListOf(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span> , <span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span> )</span><br></pre></td></tr></table></figure><h4 id="不可变集合List"><a href="#不可变集合List" class="headerlink" title="不可变集合List"></a>不可变集合List</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list: List&lt;String&gt; = listOf(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span> , <span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span> )</span><br></pre></td></tr></table></figure><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>它不允许存在重复元素，通常情况下是无序的，如果非要访问第N个元素，可以用迭代器来访问</p><h4 id="可变Set集合-MutableSet"><a href="#可变Set集合-MutableSet" class="headerlink" title="可变Set集合 MutableSet"></a>可变Set集合 MutableSet</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">mutableSetOf</span><span class="params">(<span class="keyword">vararg</span> elements: <span class="type">T</span>)</span></span>: MutableSet&lt;T&gt; </span><br></pre></td></tr></table></figure><blockquote><p>底层是 LinkedHashSet</p></blockquote><h4 id="不可变Set集合-Set"><a href="#不可变Set集合-Set" class="headerlink" title="不可变Set集合 Set"></a>不可变Set集合 Set</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">setOf</span><span class="params">()</span></span>: Set&lt;T&gt;</span><br></pre></td></tr></table></figure><h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set1 = mutableSetOf(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> set2 = mutableSetOf(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集(和 + 运算效果一样)</span></span><br><span class="line">println(set1 union  set2)<span class="comment">//A B C D</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求交集</span></span><br><span class="line">println((set1 intersect set2)) <span class="comment">//B C</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求差集(和 - 运算效果一样)</span></span><br><span class="line">println((set1 subtract set2))  <span class="comment">// A</span></span><br></pre></td></tr></table></figure><blockquote><p>集合相关操作也可以应用于List集合，但是计算得到的结果始终是Set集合</p></blockquote><h4 id="其他用于创建的预设函数"><a href="#其他用于创建的预设函数" class="headerlink" title="其他用于创建的预设函数"></a>其他用于创建的预设函数</h4><p>HashSet</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = hashSetOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;DDD&quot;</span>, <span class="string">&quot;BBB&quot;</span>)   <span class="comment">//创一个不重复且无序的Set集合</span></span><br></pre></td></tr></table></figure><p>LinkedSet</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = linkedSetOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;DDD&quot;</span>, <span class="string">&quot;BBB&quot;</span>)  <span class="comment">//跟mutableSetOf一样得到一个不重复且有序的Set集合</span></span><br></pre></td></tr></table></figure><p>元素自动排序的Set集合，可自定义排序规则，SortedSet</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortedSet = sortedSetOf(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h4 id="HashSet判断元素是否相同的过程"><a href="#HashSet判断元素是否相同的过程" class="headerlink" title="HashSet判断元素是否相同的过程"></a>HashSet判断元素是否相同的过程</h4><ol><li>计算HashCode：调用对象的<code>hashCode()</code>函数</li><li>比较HasCode：如果俩元素的HashCode相同，则计算机认为这是2个不同的元素；如果相同则进行步骤3</li><li>调用<code>equals()</code>函数：若两个元素的哈希码相同，这可能是不同元素出现了哈希冲突，所以此时计算机会调用对象的<code>equals()</code>函数进行比较，只有当<code>equals()</code>函数返回为true时，计算机认为这是同一个元素</li></ol><blockquote><ol><li>重写 <code>equals()</code> 方法时，必须同时重写 <code>hashCode()</code> 方法，以保证两个相等的对象具有相同的哈希码，这是 对象相等性的基本要求</li><li>如果没有重写<code>equals()</code>方法和<code>hashCode()</code>函数，计算机会调用Any类的默认实现—比较对象的引用&#x3D;&#x3D;&#x3D;</li></ol></blockquote><h4 id="重写equlas-的同时，必须重写hashCode"><a href="#重写equlas-的同时，必须重写hashCode" class="headerlink" title="重写equlas()的同时，必须重写hashCode()"></a>重写equlas()的同时，必须重写hashCode()</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算并返回对象的哈希值，哈希函数的计算结果需要满足以下标准:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * * 标准1: 对同一个对象调用此函数时，应该始终返回同一个哈希值，除非重写过类的equals函数，修改过比较方式</span></span><br><span class="line"><span class="comment"> * * 标准2: 如果两个对象使用equals函数判断的结果为相同，那么它们计算得到的哈希值也应该相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span></span><br></pre></td></tr></table></figure><p><code>hashCode()</code>默认返回对象在内存中存放的地址，以int类型表示</p><h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><h4 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt; = Pair(<span class="keyword">this</span>, that)</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pair: Pair&lt;<span class="built_in">Int</span>,String&gt; = <span class="number">100</span> to <span class="string">&quot;小红&quot;</span></span><br></pre></td></tr></table></figure><h4 id="创建Map"><a href="#创建Map" class="headerlink" title="创建Map"></a>创建Map</h4><h5 id="可变Map集合-MutableMap"><a href="#可变Map集合-MutableMap" class="headerlink" title="可变Map集合(MutableMap)"></a>可变Map集合(MutableMap)</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> <span class="title">mutableMapOf</span><span class="params">(<span class="keyword">vararg</span> pairs: <span class="type">Pair</span>&lt;<span class="type">K</span>, V&gt;)</span></span>: MutableMap&lt;K, V&gt; </span><br></pre></td></tr></table></figure><h5 id="不可变Map集合-Map"><a href="#不可变Map集合-Map" class="headerlink" title="不可变Map集合(Map)"></a>不可变Map集合(Map)</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> <span class="title">mapOf</span><span class="params">(<span class="keyword">vararg</span> pairs: <span class="type">Pair</span>&lt;<span class="type">K</span>, V&gt;)</span></span>: Map&lt;K, V&gt;</span><br></pre></td></tr></table></figure><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与该键关联的前一个值，或 null 如果key不在map上</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(key: <span class="type">K</span>, value: <span class="type">V</span>)</span></span>: V?</span><br><span class="line"></span><br><span class="line">map[key: K] = Value: V</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其他花式添加</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newMap = map + (<span class="number">10004</span> to Student(<span class="string">&quot;小强&quot;</span>, <span class="number">18</span>))   <span class="comment">//添加新的键值对并生成一个新的Map</span></span><br><span class="line">map += (<span class="number">10004</span> to Student(<span class="string">&quot;小强&quot;</span>, <span class="number">18</span>))  <span class="comment">//直接添加键值对到当前Map里面</span></span><br><span class="line">map += mapOf(<span class="number">10004</span> to Student(<span class="string">&quot;小强&quot;</span>, <span class="number">18</span>))  <span class="comment">//或者添加其他Map到此Map中</span></span><br><span class="line">map.putAll(mapOf(<span class="number">10004</span> to Student(<span class="string">&quot;小强&quot;</span>, <span class="number">18</span>)))   <span class="comment">//添加其他Map到此Map中</span></span><br><span class="line">map.putAll(setOf(<span class="number">10004</span> to Student(<span class="string">&quot;小强&quot;</span>, <span class="number">18</span>)))   <span class="comment">//键值对集合也可以的</span></span><br></pre></td></tr></table></figure><ul><li>注意一个Key只能对应一个Value，重复赋值会被覆盖</li></ul><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从此映射中删除指定的键及其对应的值。</span></span><br><span class="line"><span class="comment">//返回:与该键关联的前一个值，或 null 如果key不在Map上。</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(key: <span class="type">K</span>)</span></span>: V?</span><br><span class="line"></span><br><span class="line"><span class="comment">//仅当指定键映射到指定值时，才删除指定键的项。</span></span><br><span class="line"><span class="comment">//返回:如果条目被删除，则为True</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(key: <span class="type">K</span>, value: <span class="type">V</span>)</span></span>: <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure><ul><li><p>其他花式移除</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map -= <span class="number">10001</span>   <span class="comment">//等价于 map.remove(10001)</span></span><br><span class="line">map -= listOf(<span class="number">10001</span>, <span class="number">10002</span>)   <span class="comment">//批量移除</span></span><br></pre></td></tr></table></figure></li><li><p>根据Value删除键值对</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.values.remove(value: V)</span><br><span class="line"><span class="comment">//通过这种方式移除也只会移除按顺序下来的第一个</span></span><br></pre></td></tr></table></figure><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><p>同增</p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>使用<code>[]</code>运算符通过Key查找Value</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">K</span>)</span></span>: V?</span><br><span class="line"></span><br><span class="line">map.getOrDefault(key: K, defaultValue: V)<span class="comment">//使用getOrDefault在没有结果时返回给定的默认值</span></span><br><span class="line">map.getOrElse(key: K, defaultValue: () -&gt; V)<span class="comment">//跟上面一样，只不过是使用函数式返回默认值</span></span><br><span class="line">map.getOrPut(key: K, defaultValue: V)<span class="comment">//在没有返回值的时候把默认值给加到Map里面去,并返回</span></span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = mutableMapOf(</span><br><span class="line">        <span class="number">1</span> to Student(<span class="string">&quot;小红&quot;</span>, <span class="number">18</span>),</span><br><span class="line">        <span class="number">2</span> to Student(<span class="string">&quot;小明&quot;</span>,<span class="number">12</span>),</span><br><span class="line">        <span class="number">3</span> to Student(<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">var</span> student: Student? = map[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><ul><li>注意：得到的结果是一个可空的类型—–&gt;当Map中不存在指定的Key时，会直接得到null作为结果</li></ul></blockquote><ul><li>查询是否存在</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询是否包含Key</span></span><br><span class="line">map.contains(key: K)</span><br><span class="line">map.containsKey()</span><br><span class="line">key <span class="keyword">in</span> map</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是包含指定Value</span></span><br><span class="line">map.containsValue(value: V)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>注意：只能通过Key去访问Value，而不能通过Value去访问Key，映射关系是单向的</p></li><li><p>获取keys，values</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.keys</span><br><span class="line">map.values</span><br></pre></td></tr></table></figure><h4 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach &#123; k, v -&gt;</span><br><span class="line">    println(<span class="string">&quot;键:<span class="variable">$k</span>,值<span class="variable">$v</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>接口：Iterable</p><p>生成迭代器函数：public operator fun iterator(): Iterator<T></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">//获取下一个待遍历元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果还有元素没有遍历，那么返回true否则返回false，而这个函数也是运算符重载函数正好对应着 for in 操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于指针</p><blockquote><ul><li>初始时：</li></ul><p>​|A|B|C|</p><p>​↑</p><ul><li>调用next()：指针往后移动，并返回当前所指对象。直到完成每一个元素的遍历</li></ul><p>​|A|B|C|</p><p>​↑</p></blockquote><p>集合类的实现方案有很多，可能是链式存储，也有可能是数组存储，不同的实现有着不同的遍历方式，而迭代器则可以将多种多样不同的集合类遍历方式进行统一，只需要各个集合类根据自己的情况进行对应实现就行了</p><p>同一了集合的遍历操作</p><h4 id="遍历数组，集合"><a href="#遍历数组，集合" class="headerlink" title="遍历数组，集合"></a>遍历数组，集合</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    println(iterator.next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>注意，迭代器的使用是一次性的，用了之后就不能用了，如果需要再次进行遍历操作，那么需要重新生成一个迭代器对象。</li></ul></blockquote><h4 id="实现Iterable接口"><a href="#实现Iterable接口" class="headerlink" title="实现Iterable接口"></a>实现Iterable接口</h4><p>这个接口实不实现其实都无所谓  </p><p>主要是运算符重载函数iterator是必须要的，否则不支持</p><p><code>operator fun iterator()</code>函数重载的运算符就是<code>for..in</code>，所以只要实现了<code>iterator()</code>就可以进行for..in</p><p>for in 最终都会编译成while操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>)   <span class="comment">//编译前</span></span><br><span class="line"><span class="keyword">for</span> (s <span class="keyword">in</span> list) &#123;</span><br><span class="line">    list.add(<span class="string">&quot;DDD&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>)   <span class="comment">//编译后</span></span><br><span class="line"><span class="keyword">val</span> iterator: Iterator&lt;String&gt; = list.iterator()</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">val</span> next = iterator.next()</span><br><span class="line">    println(next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> iterator: ListIterator&lt;String&gt; = list.listIterator()   <span class="comment">//使用listIterator函数来获取ListIterator</span></span><br><span class="line">println(iterator.next())  <span class="comment">//不仅可以正着迭代</span></span><br><span class="line">println(iterator.nextIndex())   <span class="comment">//还可以直接告诉你下一个迭代的是List的第几个元素</span></span><br><span class="line">println(iterator.previous())   <span class="comment">//还能反着来</span></span><br></pre></td></tr></table></figure><h4 id="MutableIterator"><a href="#MutableIterator" class="headerlink" title="MutableIterator"></a>MutableIterator</h4><p>在JVM环境下，Kotlin默认不支持在迭代时修改集合里面的内容，无论是插入新的元素还是移除元素，都会触发并发修改异常。</p><p>为解决这个问题，Kotlin为所有的MutableCollection（所有非只读集合类）提供了一个特殊的用于生成MutableIterator的函数，只要我们使用的不是只读的集合类，都可以获得这个特殊的迭代器，它支持在遍历时对元素进行<strong>删除</strong> (不能插入)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutableiterator.remove()   <span class="comment">//删除当前迭代器已经遍历的最后一个元素</span></span><br></pre></td></tr></table></figure><h3 id="集合与数组的扩展操作"><a href="#集合与数组的扩展操作" class="headerlink" title="集合与数组的扩展操作"></a>集合与数组的扩展操作</h3><h4 id="数组to集合"><a href="#数组to集合" class="headerlink" title="数组to集合"></a>数组to集合</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.toList()</span><br><span class="line">array.toMutableList()</span><br><span class="line">array.toSet()</span><br></pre></td></tr></table></figure><h4 id="映射map"><a href="#映射map" class="headerlink" title="映射map"></a>映射map</h4><p>注意这里说的map跟我们前面说的集合Map是两个概念</p><p>集合（如 <code>List</code>、<code>Set</code>）,序列 Sequence调用 <code>map</code> 函数时，会遍历集合中的每个元素，将其传入给定的转换函数进行处理，然后把处理结果收集到一个新的集合中返回。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带索引</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">mapIndexed</span><span class="params">(transform: (<span class="type">index</span>: <span class="type">Int</span>, <span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: List&lt;R&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(transform: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: List&lt;R&gt; </span><br></pre></td></tr></table></figure><p>对于Map类型，我们还可以单独对所有Key或是Value进行操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbersMap = mapOf(<span class="string">&quot;key1&quot;</span> to <span class="number">1</span>, <span class="string">&quot;key2&quot;</span> to <span class="number">2</span>, <span class="string">&quot;key3&quot;</span> to <span class="number">3</span>)</span><br><span class="line">numbersMap.mapKeys &#123;  &#125;  <span class="comment">//对所有的Key进行Map操作</span></span><br><span class="line">numbersMap.mapValues &#123; it.value + it.key.length &#125;</span><br></pre></td></tr></table></figure><h4 id="压缩操作"><a href="#压缩操作" class="headerlink" title="压缩操作"></a>压缩操作</h4><p>它可以将当前集合元素和另一个集合中具有<strong>相同索引</strong>的元素组合起来，生成一个装满Pair的列表</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = listOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> pairs: List&lt;Pair&lt;<span class="built_in">Int</span>, String&gt;&gt; = list1.zip(list2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用压缩操作我们可以快速将两个List集合揉成一个Map集合</span></span><br><span class="line"><span class="keyword">val</span> map = mutableMapOf&lt;<span class="built_in">Int</span>, String&gt;()</span><br><span class="line">map.putAll(list1.zip(list2))</span><br><span class="line">println(map)  <span class="comment">//结果 &#123;1=AAA, 2=BBB, 3=CCC&#125;</span></span><br></pre></td></tr></table></figure><h4 id="解压操作"><a href="#解压操作" class="headerlink" title="解压操作"></a>解压操作</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span> to <span class="string">&quot;AAA&quot;</span>, <span class="number">2</span> to <span class="string">&quot;BBB&quot;</span>, <span class="number">3</span> to <span class="string">&quot;CCC&quot;</span>)  <span class="comment">//把合在一起的Pair每个元素都分开</span></span><br><span class="line"><span class="keyword">val</span> unzipList: Pair&lt;List&lt;<span class="built_in">Int</span>&gt;, List&lt;String&gt;&gt; = list.unzip()  <span class="comment">//转换出来是一个存放两个List的Pair</span></span><br><span class="line"><span class="comment">//Pair的key是所有key的列表，value是所有value的列表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="associate操作"><a href="#associate操作" class="headerlink" title="associate操作"></a><code>associate</code>操作</h4><p>将普通集合转换为Map映射</p><ol><li><code>associateWith</code>：以列表中每个元素为Key，提供一个函数，返回值作为生成的Map对应Key的Value</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>)</span><br><span class="line"><span class="comment">//使用associateWith快速构建以列表中每个元素为Key的Map映射</span></span><br><span class="line"><span class="keyword">val</span> associate: Map&lt;String, <span class="built_in">Int</span>&gt; = list.associateWith &#123; it.length &#125;   <span class="comment">//提供一个函数，返回值作为生成的Map对应Key的Value</span></span><br><span class="line"><span class="comment">//结果 &#123;AAA=3, BBB=3, CCC=3&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>associateBy</code>：构建以列表中每个元素为Value的Map映射，返回值作为生成的Map对应Value的Key</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>)</span><br><span class="line"><span class="comment">//使用associateBy快速构建以列表中每个元素为Value的Map映射</span></span><br><span class="line"><span class="keyword">val</span> associate: Map&lt;<span class="built_in">Int</span>, String&gt; = list.associateBy &#123; it.length &#125;   <span class="comment">//提供一个函数，返回值作为生成的Map对应Value的Key</span></span><br><span class="line"><span class="comment">//结果&#123;3=CCC&#125;，因为上面生产出来的Key全是3，覆盖完只剩下最后一个了</span></span><br></pre></td></tr></table></figure><ul><li>由于列表的元素是可以重复的，但是Map的Key是不能重复的，所以，当有多个重复的，当生成了多个重复的key时，以最后一个为主</li></ul><ol start="3"><li><code>associate</code>：自行构建一个Pair作为结果返回</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> associate: Map&lt;String, <span class="built_in">Int</span>&gt; = list.associate &#123; it to it.length &#125;  <span class="comment">//返回一个Pair</span></span><br></pre></td></tr></table></figure><h4 id="扁平化操作"><a href="#扁平化操作" class="headerlink" title="扁平化操作"></a>扁平化操作</h4><p>把这个嵌套的集合内所有的集合全部拆出来</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(listOf(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>), listOf(<span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;DDD&quot;</span>))</span><br><span class="line"><span class="keyword">val</span> flatten: List&lt;String&gt; = list.flatten()   <span class="comment">//使用flatten函数将嵌套集合扁平化</span></span><br><span class="line"><span class="comment">//可以看到内容自动被展平了 [AAA, BBB, CCC, DDD]</span></span><br></pre></td></tr></table></figure><h4 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h4><p>将扁平的集合嵌套</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;DDD&quot;</span>)</span><br><span class="line"><span class="comment">//使用chunked进行分块，这里2个元素为一组进行分块，得到一个嵌套的集合</span></span><br><span class="line">println(list.chunked(<span class="number">2</span>))   <span class="comment">//结果 [[AA, BBB], [CC, DDD]]</span></span><br></pre></td></tr></table></figure><h4 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h4><p>提供一个函数作为过滤标准，返回一个新的集合</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">filter</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: List&lt;T&gt;</span><br></pre></td></tr></table></figure><p>快速过滤所有空值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;AAA&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;BBB&quot;</span>, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">val</span> filterList: List&lt;String&gt; = list.filterNotNull()</span><br><span class="line">println(filterList)   <span class="comment">//结果 [AAA, BBB]</span></span><br></pre></td></tr></table></figure><p>快速过滤出指定类型的集合</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;AAA&quot;</span>, Any(), <span class="string">&quot;BBB&quot;</span>, <span class="number">123</span>, <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">val</span> filterList: List&lt;String&gt; = list.filterIsInstance&lt;String&gt;()  <span class="comment">//快速过滤出所有的String元素</span></span><br><span class="line">println(filterList)   <span class="comment">//结果 [AAA, BBB]</span></span><br></pre></td></tr></table></figure><h4 id="分区操作"><a href="#分区操作" class="headerlink" title="分区操作"></a>分区操作</h4><p>过滤操作可以快速筛选出我们需要的那些元素，当然，如果我们既需要筛选出来的元素，也需要筛选出去的元素，我们可以使用分区操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">partition</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: Pair&lt;List&lt;T&gt;, List&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;DDD&quot;</span>)</span><br><span class="line"><span class="comment">//分区操作得到一个匹配列表和一个不匹配列表</span></span><br><span class="line"><span class="keyword">val</span> (match, mismatch) = list.partition &#123; it.length &gt; <span class="number">2</span> &#125;</span><br><span class="line">println(<span class="string">&quot;匹配的列表: <span class="variable">$match</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;不匹配的列表: <span class="variable">$mismatch</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="分组操作"><a href="#分组操作" class="headerlink" title="分组操作"></a>分组操作</h4><p>它可以将元素按类别进行分组，以Map的形式返回：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;DDD&quot;</span>)</span><br><span class="line">println(list.groupBy &#123; it.length &#125;)  <span class="comment">//按照字符串的长度进行分组</span></span><br><span class="line"><span class="comment">//得到 &#123;2=[AA, CC], 3=[BBB, DDD]&#125;</span></span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><a href="https://kotlinlang.org/docs/collections-overview.html">https://kotlinlang.org/docs/collections-overview.html</a></p><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>除了集合，Kotlin标准库还包含另一种类型：<em>序列</em>（<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html"><code>Sequence</code></a>）与集合不同，序列不包含元素，它在运行时生成元素</p><p><code>Sequence</code>接口与<code>Iterable</code>接口类似，只包含一个生成迭代器的函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sequence</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成迭代器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>性能优化—惰性</strong></li></ul><p>序列实际上是一个延迟获取数据的集合，只有需要元素时才会生产元素，并提供给外部，包括所有对元素操作，并不是一次性全部处理，而是根据情况选择合适的元素进行操作。使用序列能够在处理大量数据时获得显著的性能提升</p><p>序列并不是随时随地都可以使用的，我们还是要根据实际情况决定是否要使用序列，如果在数据量特别庞大的情况下，使用序列处理会更好，但是如果数据量很小，使用序列反而会增加开销</p><h1 id="Kotlin特殊类型"><a href="#Kotlin特殊类型" class="headerlink" title="Kotlin特殊类型"></a>Kotlin特殊类型</h1><h2 id="数据类型-data-class"><a href="#数据类型-data-class" class="headerlink" title="数据类型(data class)"></a>数据类型(data class)</h2><p>Kotlin为我们提供了专门的数据类，数据类不仅能像普通类一样使用，并且自带我们需要的额外成员函数，比如打印到输出、比较实例、复制实例等</p><p>数据类声明后，编译器会根据<strong>主构造函数</strong>中声明的所有属性自动为其生成以下函数：</p><ul><li><code>.equals()</code>&#x2F;<code>.hashCode()</code></li><li><code>.toString()</code>生成的字符串格式</li><li><code>.componentN()</code>与按声明顺序自动生成用于解构的函数</li><li><code>.copy()</code>用于对对象进行拷贝(浅拷贝)</li></ul><p>注意，编译器会且只会根据主构造函数中定义的属性生成对应函数，如果有些时候我们不希望某些属性被添加到自动生成的函数中，我们需要手动将其移出主构造函数，用辅助函数初始化</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String)&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">18</span> <span class="comment">//age属性不会被处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>):<span class="keyword">this</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类型-enum-class"><a href="#枚举类型-enum-class" class="headerlink" title="枚举类型(enum class)"></a>枚举类型(enum class)</h2><p>用于表示一组固定的常量值</p><h3 id="定义枚举类"><a href="#定义枚举类" class="headerlink" title="定义枚举类"></a>定义枚举类</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类前面添加enum表示这是一个枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">LightState</span> &#123;</span><br><span class="line">    GREEN, YELLOW, RED   <span class="comment">//直接在枚举类内部写上所有枚举的名称，一般全部用大写字母命名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类的值只能是我们在类中定义的那些枚举，不可以存在其他的结果，枚举类型同样也是一个普通的类，只是存在值的限制。</p><h3 id="定义成员"><a href="#定义成员" class="headerlink" title="定义成员"></a>定义成员</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同样可以定义成员变量，但是不能命名为name，因为name拿来返回枚举名称了</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">LightState</span>(<span class="keyword">val</span> color: String) &#123;</span><br><span class="line">    GREEN(<span class="string">&quot;绿灯&quot;</span>), YELLOW(<span class="string">&quot;黄灯&quot;</span>), RED(<span class="string">&quot;红灯&quot;</span>);  <span class="comment">//枚举在定义时也必须填写参数，如果后面还要编写成员函数之类的其他内容，还需在末尾添加分号结束</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">isGreen</span><span class="params">()</span></span> = <span class="keyword">this</span> == LightState.GREEN  <span class="comment">//定义一个函数也是没问题的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举中的抽象函数"><a href="#枚举中的抽象函数" class="headerlink" title="枚举中的抽象函数"></a>枚举中的抽象函数</h3><p>在枚举类中也可以编写抽象函数，抽象函数需要由枚举自行实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">LightState</span> &#123;</span><br><span class="line">    GREEN&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;我是绿灯&quot;</span>)</span><br><span class="line">    &#125;, YELLOW&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;我是黄灯&quot;</span>)</span><br><span class="line">    &#125;, RED&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;我是红灯&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举中的接口"><a href="#枚举中的接口" class="headerlink" title="枚举中的接口"></a>枚举中的接口</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">LightState</span> : <span class="type">Message</span>&#123;</span><br><span class="line">    GREEN&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;我是绿灯&quot;</span>)</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span> = println(<span class="string">&quot;绿灯行&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;, YELLOW&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;我是黄灯&quot;</span>)</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span> = println(<span class="string">&quot;黄灯减速&quot;</span>)</span><br><span class="line">    &#125;, RED&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = println(<span class="string">&quot;我是红灯&quot;</span>)</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span> = println(<span class="string">&quot;红灯停&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以在这里统一实现</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span> &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="枚举的其他函数"><a href="#枚举的其他函数" class="headerlink" title="枚举的其他函数"></a>枚举的其他函数</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> state: LightState = LightState.valueOf(<span class="string">&quot;RED&quot;</span>)   <span class="comment">//通过valueOf函数以字符串名称的形式转换为对应名称的枚举</span></span><br><span class="line"><span class="keyword">val</span> state: LightState = enumValueOf&lt;LightState&gt;(<span class="string">&quot;RED&quot;</span>)   <span class="comment">//同上</span></span><br><span class="line">println(state)</span><br><span class="line">println(state.ordinal)   <span class="comment">//枚举在第几个位置</span></span><br><span class="line">println(state.name)   <span class="comment">//枚举名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> entries: EnumEntries&lt;LightState&gt; = LightState.entries  <span class="comment">//一键获取全部枚举，得到的结果是EnumEntries类型的，他是List的子接口，因此可以当做List来使用</span></span><br><span class="line"><span class="keyword">val</span> values: Array&lt;LightState&gt; = enumValues&lt;LightState&gt;()   <span class="comment">//或者像这样以Array形式获取到所有的枚举</span></span><br><span class="line">println(entries)</span><br></pre></td></tr></table></figure><h2 id="匿名类和伴生对象"><a href="#匿名类和伴生对象" class="headerlink" title="匿名类和伴生对象"></a>匿名类和伴生对象</h2><p>在某些时候，我们只需要临时使用一下某个类，并不需要通过class关键字定义对象，而是以匿名的形式创建一个临时对象，在使用完之后就不再需要了，这种情况完全没有必要定义一个完成的类型，而是可以使用匿名类的方式（特别是某些接口）</p><p><strong>在需要创建一个只使用一次的类实例</strong></p><h3 id="匿名类的创建object"><a href="#匿名类的创建object" class="headerlink" title="匿名类的创建object"></a>匿名类的创建<code>object</code></h3><p>匿名类除了没名字之外，也可以定义成员，只不过这种匿名类不能定义任何构造函数，因为它是直接创建的，这种写法我们也可以叫做<strong>对象表达式</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用object关键字声明一个匿名类并创建其对象，可以直接使用变量接收得到的对象</span></span><br><span class="line"><span class="keyword">val</span> obj = <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">&quot;匿名类&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String =<span class="string">&quot;我是<span class="subst">$&#123;name&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(obj)</span><br></pre></td></tr></table></figure><ul><li>使用<code>object</code>关键字：声明一个匿名类并创建其对象，可以直接使用变量接收得到的对象</li><li><em>匿名类默认继承于Any</em></li></ul><h3 id="继承-抽象类，接口，类"><a href="#继承-抽象类，接口，类" class="headerlink" title="继承 抽象类，接口，类"></a>继承 抽象类，接口，类</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> :Message&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span>= println(<span class="string">&quot;我是匿名类实现接口&quot;</span>)</span><br><span class="line">    &#125;.speakMessage()</span><br></pre></td></tr></table></figure><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>对于只存在一个抽象函数的接口称为<strong>函数式接口</strong>或<strong>单一抽象方法（SAM）接口</strong>，函数式接口可以有N个非抽象成员，但是<strong>只能有一个抽象成员</strong>。对于函数式接口，可以使用我们前面介绍的Lambda表达式来使代码更简洁</p><p>**函数式接口：**一个抽象成员，多个非抽象成员</p><h4 id="定义函数式接口"><a href="#定义函数式接口" class="headerlink" title="定义函数式接口"></a>定义函数式接口</h4><p>在interface之前使用fun关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在接口声明前面添加fun关键字，声明这是一个函数式接口</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Message &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Lambda来定义函数式接口中的抽象成员</span></span><br><span class="line"><span class="keyword">val</span> message = Message&#123;</span><br><span class="line">        println(<span class="string">&quot;我是函数式接口&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="因为匿名产生的些许问题"><a href="#因为匿名产生的些许问题" class="headerlink" title="因为匿名产生的些许问题"></a>因为匿名产生的些许问题</h3><p>因为有了匿名类，所以有些时候我们通过函数得到的结果，可能并不是某个具体定义的类型，也有可能是直接采用匿名形式创建的匿名类对象，这是返回的对象只能当作匿名类继承的类使用</p><p>例如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Human</span>(<span class="keyword">var</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>= <span class="keyword">object</span>: Human(<span class="string">&quot;小帅&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> age:<span class="built_in">Int</span>=<span class="number">20</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">&quot;我是<span class="variable">$name</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> test:Human = test()<span class="comment">//返回的类型是Human，由于其匿名特性，只能当做Human使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例类型"><a href="#单例类型" class="headerlink" title="单例类型"></a>单例类型</h2><p><code>object</code>关键字不仅可以用于声明匿名类型，也可以用于声明<strong>单例类</strong></p><ul><li>单例类：在整个程序中只能存在一个对象，也就是单个实例，不可以创建其他的对象，始终使用的只能是那一个对象</li></ul><p>通过类名直接得到此单例类的对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name = <span class="string">&quot;单例&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">&quot;我是<span class="subst">$&#123;name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> singleton = Singleton   <span class="comment">//通过类名直接得到此单例类的对象</span></span><br><span class="line">    <span class="comment">//不可以通过构造函数的形式创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>单例类的这种性质在很多情况下都很方便，比如我们要编写某些工具操作，可以直接使用单例类的形式编写</p></blockquote><h2 id="伴生对象-有种java中的static的感jio"><a href="#伴生对象-有种java中的static的感jio" class="headerlink" title="伴生对象(有种java中的static的感jio)"></a>伴生对象(有种java中的static的感jio)</h2><p>既希望像单例类那样直接调用，又支持像一个普通class那样使用，这时就可以使用伴生对象来实现</p><p>实际上就是将一个单例类<strong>写到某个类的内部</strong></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>使用companion关键字在内部编写一个伴生对象，它同样是单例的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String , <span class="keyword">var</span> age: <span class="built_in">Int</span> , <span class="keyword">var</span> id:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="comment">//使用companion关键字在内部编写一个伴生对象，它同样是单例的</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Tools&#123;</span><br><span class="line">        <span class="keyword">var</span> tempId:<span class="built_in">Int</span>=<span class="number">0</span></span><br><span class="line">        <span class="comment">//伴生对象定义的函数可以直接通过外部类名调用</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(name: <span class="type">String</span>,age: <span class="type">Int</span>)</span></span>:Student&#123;</span><br><span class="line">           tempId+=<span class="number">1</span></span><br><span class="line">           <span class="keyword">return</span> Student(name,age, tempId)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> createStudent:(name:String,age:<span class="built_in">Int</span>)-&gt;Student=&#123;name: String, age: <span class="built_in">Int</span> -&gt;</span><br><span class="line">            tempId+=<span class="number">1</span></span><br><span class="line">            Student(name,age, tempId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用companion关键字在内部编写一个伴生对象，它同样是单例的</li><li>伴生对象定义的函数可以直接通过外部类名调用</li></ul><h2 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h2><p>继承的一种更好的替代方案</p><h3 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h3><p>比如现在我们有一个接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Message</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们创建一个实现Message接口的类，该类有一个实现该接口的对象<code>messageImpl</code></p><p>在重写Message的接口的方法时，调用<code>messageImpl</code>对于方法的实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="keyword">var</span> messageImpl: Message) : Message &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span> = messageImpl.speakMessage() </span><br><span class="line">    <span class="comment">//真正去实现这个接口的，实际上并不是当前类，而是被拉进来的那个替身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A委托别人去完成方法</p><h3 id="原始支持by"><a href="#原始支持by" class="headerlink" title="原始支持by"></a>原始支持<code>by</code></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">speakMessage</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="keyword">val</span> messageImpl: Message) : Message <span class="keyword">by</span> messageImpl</span><br></pre></td></tr></table></figure><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> p: String <span class="keyword">by</span> lazy &#123; <span class="string">&quot;ddd&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lazy为我们生成一个委托对象，这样在获取属性值的时候就会执行lazy里面的操作了，看起来效果就像是延迟执行一样，由于只能获取，所以说只支持val变量</span></span><br></pre></td></tr></table></figure><p>获取属性值的时候就会执行lazy里面的操作了，看起来效果就像是延迟执行一样，由于只能获取，所以说只支持val变量</p><h4 id="设置检测器"><a href="#设置检测器" class="headerlink" title="设置检测器"></a>设置检测器</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> p: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;我是初始值&quot;</span>)&#123;property, oldValue, newValue -&gt;</span><br><span class="line">        println(<span class="string">&quot;检测到<span class="subst">$&#123;property&#125;</span>的值发生变化,<span class="subst">$&#123;oldValue&#125;</span>-&gt;<span class="subst">$&#123;newValue&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>有些时候，我们可能会编写一些类给其他人使用，但是我们不希望他们随意继承使用我们提供的类，我们只希望在我们提供的框架内部自己进行使用，这时我们就可以将类或接口设定为密封的</p><ul><li><p><code>sealed</code>密封类声明</p></li><li><p>密封类同一个模块或包中可以随意继承，并且子类也可以是密封的</p></li><li><p>密封类本身是抽象的</p></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h3><blockquote><p>kotlin.Throwable<br>│<br>├── kotlin.Exception<br>│   ├── java.lang.RuntimeException<br>│   │   ├── java.lang.NullPointerException<br>│   │   ├── java.lang.IllegalArgumentException<br>│   │   ├── java.lang.IllegalStateException<br>│   │   ├── java.lang.IndexOutOfBoundsException<br>│   │   └── java.lang.ClassCastException<br>│   ├── java.io.IOException<br>│   └── java.lang.InterruptedException<br>│</p><p>│</p><p>└── kotlin.Error<br> ├── java.lang.OutOfMemoryError<br> ├── java.lang.StackOverflowError<br> └── java.lang.VirtualMachineError</p></blockquote><h4 id="Throwable类"><a href="#Throwable类" class="headerlink" title="Throwable类"></a>Throwable类</h4><p><code>Throwable</code> 是所有异常和错误的根类。</p><p><code>Throwable</code> 的重要属性：</p><ul><li><code>message</code>：异常的描述信息。</li><li><code>cause</code>：导致该异常的根本原因。</li></ul><p>具有两个常用的构造函数：</p><p>constructor(message: String?) : this(message, null)</p><p>constructor(cause: Throwable?) : this(cause?.toString(), cause)</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span> (e:Exception)&#123;</span><br><span class="line">    println(e)</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;执行 finally 块&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span>():Exception(<span class="string">&quot;自定义异常&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewBinding</title>
      <link href="/2025/03/05/ViewBinding/"/>
      <url>/2025/03/05/ViewBinding/</url>
      
        <content type="html"><![CDATA[<h1 id="ViewBinding"><a href="#ViewBinding" class="headerlink" title="ViewBinding"></a>ViewBinding</h1><h2 id="什么是ViewBinding"><a href="#什么是ViewBinding" class="headerlink" title="什么是ViewBinding"></a>什么是ViewBinding</h2><p>为了避免编写findViewById()而产生的一个插件</p><p>旧的<code>kotlin-android-extensions</code>已被放用</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在你项目工程模块的build.gradle中，开启viewBinding</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    ...</span><br><span class="line">    buildFeatures&#123;</span><br><span class="line">        viewBinding <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Activity中使用"><a href="#Activity中使用" class="headerlink" title="Activity中使用"></a>Activity中使用</h2><p>启动了ViewBinding功能之后，Android Studio会自动为我们所编写的每一个布局文件都生成一个对应的Binding类</p><p>例如：activity_main.xml布局，对应生成ActivityMainBinding</p><blockquote><p>如果某布局文件不希望生成对应的Binding类，可以在该布局根元素中加入</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    tools:viewBindingIgnore=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">var</span> binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.tvMainHello.text = <span class="string">&quot;Hello Andorid&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>首先我们要调用activity_main.xml布局文件对应的Binding类，也就是ActivityMainBinding的**inflate()**函数去加载该布局，inflate()函数接收一个LayoutInflater参数</p></li><li><p>Binding类的getRoot()函数可以得到activity_main.xml中根元素的实例</p><p>调用getvMainHello()函数可以获得id为tv_main_hello的元素实例</p></li></ol></blockquote><h3 id="binding全局变量"><a href="#binding全局变量" class="headerlink" title="binding全局变量"></a>binding全局变量</h3><p>如果你需要在onCreate()函数之外的地方对控件进行操作，那么就得将binding变量声明成全局变量</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.tvMainHello.text = <span class="string">&quot;Hello Andorid&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：Kotlin声明的变量都必须在声明的同时对其进行初始化。而这里我们显然无法在声明全局binding变量的同时对它进行初始化，所以这里又使用了lateinit关键字对binding变量进行了延迟初始化</p></blockquote><h2 id="Fragment中使用"><a href="#Fragment中使用" class="headerlink" title="Fragment中使用"></a>Fragment中使用</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestFragment</span>: <span class="type">Fragment</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用可空类型声明 binding 变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _binding: FragmentTestBinding? =<span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用委托属性获取非空的 binding 引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding <span class="keyword">get</span>() = _binding!!</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        _binding = FragmentTestBinding.inflate(inflater,container,<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">        _binding = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和在Activity中使用相似</p><p>调用FragmentMainBinding的inflate()函数去加载fragment_main.xml布局文件，但由于这是在Fragment当中，所以使用了3个参数的inflate()函数重载，这和我们平时在Fragment中去加载布局文件的方式如出一辙</p></blockquote><blockquote><p><strong>不同点</strong></p><p>由于我们是在onCreateView()函数中加载的布局，那么理应在与其对应的onDestroyView()函数中对binding变量置空，从而保证binding变量的有效生命周期是在onCreateView()函数和onDestroyView()函数之间</p><p>又因为，需要在onDestroyView()置空binding所以binding需要为可空类型</p></blockquote><h2 id="在Adapter中使用"><a href="#在Adapter中使用" class="headerlink" title="在Adapter中使用"></a>在Adapter中使用</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RvAdapter</span>(<span class="keyword">val</span> InfoList:List&lt;InfoData&gt;): RecyclerView.Adapter&lt;RvAdapter.ViewHolder&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ViewHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> binding = ItemContentBinding.inflate(LayoutInflater.from(parent.context), parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> ViewHolder(binding)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = InfoList.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> (title,content,imageId) = InfoList[position]</span><br><span class="line">        holder.tv_title.text=title</span><br><span class="line">        holder.tv_content.text=content</span><br><span class="line">        holder.imageView.setImageResource(imageId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">ViewHolder</span>(binding: ItemContentBinding):RecyclerView.ViewHolder(binding.root)&#123;</span><br><span class="line">        <span class="keyword">val</span> imageView: ImageView = binding.ivImg</span><br><span class="line">        <span class="keyword">val</span> tv_title: TextView = binding.tvTitle</span><br><span class="line">        <span class="keyword">val</span> tv_content: TextView = binding.tvContent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>首先，我们在**onCreateViewHolder()**函数中调用ItemContentBinding的inflate()函数去加载item_content.xml布局文件，这和ViewBinding在Fragment中的用法是一模一样的。</li><li><strong>ViewHolder</strong>，让其构造函数接收ItemContentBinding这个参数。但是注意，ViewHolder的父类RecyclerView.ViewHolder它只会接收View类型的参数，因此我们需要调用binding.root获得fruit_item.xml中根元素的实例传给RecyclerView.ViewHolder。</li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp与Retrofit</title>
      <link href="/2025/01/31/OkHttp%E4%B8%8ERetrofit/"/>
      <url>/2025/01/31/OkHttp%E4%B8%8ERetrofit/</url>
      
        <content type="html"><![CDATA[<h1 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><strong>并行、串行、并发</strong> —— <strong>任务执行方式</strong>（进程&#x2F;线程如何执行任务）</p><blockquote><p><strong>串行</strong>：任务按顺序逐个执行，每个任务必须等待上一个任务完成后才能开始</p><p><strong>并行</strong>：多个任务<strong>真正同时执行</strong>，通常需要多个线程或多个 CPU 核心来实现。每个任务在不同的核心或线程上运行，任务之间不会交替，而是<strong>同时进行</strong></p><p><strong>并发：多个任务看似在同一时间进行，但实际上它们是</strong>交替执行**的。操作系统可能会在多个任务之间进行切换，通常是在单线程或少数线程的环境下</p></blockquote><p><strong>同步、异步</strong> —— <strong>任务提交和等待机制</strong>（任务是如何提交、如何等待结果）</p><blockquote><p><strong>同步</strong>：当任务被提交时，调用者会等待任务完成才能继续执行后续操作。任务完成后才返回结果或继续执行。是<strong>阻塞</strong>的，调用者在任务完成前无法进行其他操作。</p><p><strong>异步</strong>：当任务被提交时，调用者不会等待任务完成，而是<strong>立即返回</strong>，并在任务完成时通过回调函数或通知机制来获取结果。调用者可以继续做其他工作，任务完成后会触发回调。<strong>非阻塞</strong>的，调用者可以在等待期间做其他事。</p></blockquote><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.squareup.okhttp3:okhttp:4.9.0&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><h3 id="创建OkhttpClient（请求器）"><a href="#创建OkhttpClient（请求器）" class="headerlink" title="创建OkhttpClient（请求器）"></a>创建OkhttpClient（请求器）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br></pre></td></tr></table></figure><h3 id="创建Request（设置请求的参数）"><a href="#创建Request（设置请求的参数）" class="headerlink" title="创建Request（设置请求的参数）"></a>创建Request（设置请求的参数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;https://www.httpbin.org/get&quot;</span>).build();</span><br></pre></td></tr></table></figure><h3 id="获取准备好请求的Call对象"><a href="#获取准备好请求的Call对象" class="headerlink" title="获取准备好请求的Call对象"></a>获取准备好请求的Call对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> okHttpClient.newCall(request);</span><br></pre></td></tr></table></figure><h3 id="进行访问"><a href="#进行访问" class="headerlink" title="进行访问"></a>进行访问</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>同步访问需要直接手动开辟一个新的线程进行网络访问，因为如果不开通则会阻塞主线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call.execute();<span class="comment">//同步</span></span><br></pre></td></tr></table></figure><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>异步访问不需要自己手动开辟一个新的线程，在 OkHttp 中，使用 <strong><code>enqueue()</code></strong> 方法来执行网络请求时，它内部会为我们创建一个子线程，而不是直接在主线程（UI线程）中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(<span class="meta">@NonNull</span> Call call, <span class="meta">@NonNull</span> IOException e)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用onResponse代表与服务器的沟通成功，并不一定是拿到了数据</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(<span class="meta">@NonNull</span> Call call, <span class="meta">@NonNull</span> Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">if</span> (response.isSuccessful())&#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;onResponse: &quot;</span>+response.body().string());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>其他步骤与get相同，在创建Request的时候有差别</p><h3 id="创建Request（设置请求的参数），与get有差别"><a href="#创建Request（设置请求的参数），与get有差别" class="headerlink" title="创建Request（设置请求的参数），与get有差别"></a>创建Request（设置请求的参数），与get有差别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FormBody</span> <span class="variable">formBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder().add(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;1&quot;</span>).add(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;2&quot;</span>).build();</span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;https://https://www.httpbin.org/post&quot;</span>).post(formBody).</span><br><span class="line">    build();</span><br></pre></td></tr></table></figure><p>Request.Builder()默认是Get所以不用写<code>.get()</code>,但当post的时候需要声明<code>.post(RequestBody)</code>(请求体),<code>FormBody</code> 可以用来构建 <strong>键值对</strong> 数据</p><h2 id="最后附上源码"><a href="#最后附上源码" class="headerlink" title="最后附上源码"></a>最后附上源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OkHttpClient okHttpClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span><span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        okHttpClient=<span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//get同步请求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSync</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;https://www.httpbin.org/get&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取准备好请求的Call对象</span></span><br><span class="line">                <span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> okHttpClient.newCall(request);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> call.execute();</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;getSync: &quot;</span>+response.body().string());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get异步请求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAsync</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;https://v1.hitokoto.cn/&quot;</span>).build();</span><br><span class="line">        <span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> okHttpClient.newCall(request);</span><br><span class="line">        call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(<span class="meta">@NonNull</span> Call call, <span class="meta">@NonNull</span> IOException e)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(<span class="meta">@NonNull</span> Call call, <span class="meta">@NonNull</span> Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">if</span> (response.isSuccessful())&#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;onResponse: &quot;</span>+response.body().string());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//post同步请求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postSync</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">FormBody</span> <span class="variable">formBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder().add(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;1&quot;</span>).add(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;2&quot;</span>).build();</span><br><span class="line">                <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;https://www.httpbin.org/post&quot;</span>).post(formBody).build();</span><br><span class="line">                <span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> okHttpClient.newCall(request);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> call.execute();</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;run: &quot;</span>+response.body().string());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;run: &quot;</span>+e.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//post异步请求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postAsync</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="type">FormBody</span> <span class="variable">formBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder().add(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;1&quot;</span>).add(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;1&quot;</span>).build();</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;https://www.httpbin.org/post&quot;</span>).post(formBody).build();</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;postAsync1: &quot;</span>+request.body().toString());</span><br><span class="line">        <span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> okHttpClient.newCall(request);</span><br><span class="line">        call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(<span class="meta">@NonNull</span> Call call, <span class="meta">@NonNull</span> IOException e)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(<span class="meta">@NonNull</span> Call call, <span class="meta">@NonNull</span> Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">if</span> (response.isSuccessful())&#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;onResponse: &quot;</span>+response.body().string());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>协议规定了POST提交的数据必须存放在请求体中</p><p><a href="https://www.runoob.com/http/http-content-type.html">HTTP content-type | 菜鸟教程</a></p><p>Content-Type：application&#x2F;x-www-form-urlencoded 数据被编码为键值对，默认类型</p><p>Content-Type：multipart&#x2F;form-data 数据被编码成一条消息，一般用于文件上传</p><p>Content-Type：application&#x2F;octet-stream 提交二进制数据，同于文件上传，只能上传一个文件；</p><p>Content-Type：application&#x2F;json 提交json数据</p><p>and so on</p><h1 id="Builder构建者，自定义配置"><a href="#Builder构建者，自定义配置" class="headerlink" title="Builder构建者，自定义配置"></a>Builder构建者，自定义配置</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient=<span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().build();</span><br></pre></td></tr></table></figure><h3 id="拦截器-Interceptor"><a href="#拦截器-Interceptor" class="headerlink" title="拦截器 Interceptor"></a>拦截器 Interceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Interceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@NonNull</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(<span class="meta">@NonNull</span> Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">//前置处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> chain.proceed(chain.request());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//后置处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>OkHttpClient.Builder()可以添加2种拦截器</p><blockquote><p>.addInterceptor()</p><p>.addNetworkInterceptor()，只在请求成功到达服务器并且服务器返回响应之后才会被调用</p></blockquote><h3 id="Chain-的两个关键方法"><a href="#Chain-的两个关键方法" class="headerlink" title="Chain 的两个关键方法"></a><code>Chain</code> 的两个关键方法</h3><ul><li><strong><code>request()</code></strong>：获取当前请求对象。</li><li><strong><code>proceed(Request request)</code></strong>：执行链条的下一个拦截器，发送请求并获取响应</li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().cookieJar(<span class="keyword">new</span> <span class="title class_">CookieJar</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//保存Cookie，参数：httpUrl：当前请求的 URL、list：服务器返回的 Cookie 列表。</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveFromResponse</span><span class="params">(<span class="meta">@NonNull</span> HttpUrl httpUrl, <span class="meta">@NonNull</span> List&lt;Cookie&gt; list)</span> &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@NonNull</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//在发送请求前，OkHttp 会调用该方法来获取应该附加到请求中的 Cookie</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;Cookie&gt; <span class="title function_">loadForRequest</span><span class="params">(<span class="meta">@NonNull</span> HttpUrl httpUrl)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).build();</span><br></pre></td></tr></table></figure><p>在内存中保存Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,List&lt;Cookie&gt;&gt; cookies=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cookieUnitTest</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//**********创建一个自定义的OkHttpClient**********</span></span><br><span class="line">        <span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().cookieJar(<span class="keyword">new</span> <span class="title class_">CookieJar</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//保存Cookie</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveFromResponse</span><span class="params">(<span class="meta">@NonNull</span> HttpUrl httpUrl, <span class="meta">@NonNull</span> List&lt;Cookie&gt; list)</span> &#123;</span><br><span class="line">                cookies.put(httpUrl.host(),list);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@NonNull</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//给访问添加Cookie</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;Cookie&gt; <span class="title function_">loadForRequest</span><span class="params">(<span class="meta">@NonNull</span> HttpUrl httpUrl)</span> &#123;</span><br><span class="line">                List&lt;Cookie&gt; cookie = cookies.get(httpUrl.host());</span><br><span class="line">                <span class="keyword">return</span> cookie==<span class="literal">null</span>?Collections.emptyList():cookie;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).build();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="type">FormBody</span> <span class="variable">formBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder().add(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;dadadapp&quot;</span>).add(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;dddddd&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;https://www.wanandroid.com/user/login&quot;</span>).post(formBody).build();</span><br><span class="line">        <span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> okHttpClient.newCall(request);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> call.execute();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        request =<span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;https://www.wanandroid.com/lg/collect/list/0/json&quot;</span>).get().build();</span><br><span class="line">        <span class="type">Call</span> <span class="variable">call1</span> <span class="operator">=</span> okHttpClient.newCall(request);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> call1.execute();</span><br><span class="line">            System.out.println(response.body().string());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h1><p>基于OkHttp的封装</p><h2 id="Retrofit的基本使用"><a href="#Retrofit的基本使用" class="headerlink" title="Retrofit的基本使用"></a>Retrofit的基本使用</h2><h3 id="根据Http接口，创建java接口"><a href="#根据Http接口，创建java接口" class="headerlink" title="根据Http接口，创建java接口"></a>根据Http接口，创建java接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HttpbinService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST(&quot;post&quot;)</span></span><br><span class="line">    <span class="meta">@FormUrlEncoded</span></span><br><span class="line">    Call&lt;ResponseBody&gt; <span class="title function_">post</span><span class="params">(<span class="meta">@Field(&quot;username&quot;)</span> String username, <span class="meta">@Field(&quot;password&quot;)</span> String password)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(&quot;get&quot;)</span></span><br><span class="line">    Call&lt;ResponseBody&gt; <span class="title function_">get</span><span class="params">(<span class="meta">@Query(&quot;username&quot;)</span> String username , <span class="meta">@Query(&quot;password&quot;)</span> String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： Call是Retrofit包里的Call，ResponseBody是OkHttp包里的</p><h3 id="创建Retrofit的对象，并生成接口实现类对象"><a href="#创建Retrofit的对象，并生成接口实现类对象" class="headerlink" title="创建Retrofit的对象，并生成接口实现类对象"></a>创建Retrofit的对象，并生成接口实现类对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder().baseUrl(<span class="string">&quot;https://www.httpbin.org/&quot;</span>).build();</span><br><span class="line"><span class="type">HttpbinService</span> <span class="variable">httpbinService</span> <span class="operator">=</span> retrofit.create(HttpbinService.class);</span><br></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">retrofit2.Call&lt;ResponseBody&gt; call = httpbinService.post(<span class="string">&quot;hiir&quot;</span>, <span class="string">&quot;dddddd&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    call.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Retrofit的注解"><a href="#Retrofit的注解" class="headerlink" title="Retrofit的注解"></a>Retrofit的注解</h2><blockquote><p>方法注解：<code>@GET</code>、<code>@POST</code>、<code> @PUT</code>、<code>@DELETE</code>、<code>@PATH</code>、<code>@HEAD</code>、<code>@OPTIONS</code>、<code>@HTTP</code></p><p>标记注解：<code>@FormUrlEncoded</code>、<code>@Multipart</code>、<code>@Streaming</code></p><p>参数注解：<code>@Query</code>、<code>@QueryMap</code>、<code>@Body</code>、<code>@Field</code>、<code>@FieldMap</code>、<code>@Part</code>、<code>@PartMap</code></p><p>其他注解：<code>@Path</code>、<code>@Header</code>、<code>@Headers</code>、<code>@Url</code></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROOM框架</title>
      <link href="/2025/01/23/ROOM%E6%A1%86%E6%9E%B6/"/>
      <url>/2025/01/23/ROOM%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="ROOM框架"><a href="#ROOM框架" class="headerlink" title="ROOM框架"></a>ROOM框架</h1><p>Room 是 Android 官方提供的一个用于处理 SQLite 数据库的持久化库，它在 SQLite 基础上进行了封装，简化了数据库操作，提供了更直观、高效且类型安全的数据库访问方式</p><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><blockquote><p><strong>数据库（Database）</strong></p><ul><li>这是 Room 框架的核心类，需继承 <code>RoomDatabase</code> 抽象类。</li><li>利用 <code>@Database</code> 注解对其进行标注，该注解用于指定数据库包含的实体类和版本号。</li><li>为每个 <code>DAO</code>（数据访问对象）提供一个抽象方法，返回对应的 <code>DAO</code> 实例</li></ul><p><strong>实体（Entity）</strong></p><ul><li>代表数据库中的一张表，是一个 Java 或 Kotlin 类。</li><li>用 <code>@Entity</code> 注解标注，可指定表名等信息。</li><li>类中的每个字段对应表中的一列，可使用 <code>@PrimaryKey</code> 注解指定主键。</li></ul><p><strong>数据访问对象（DAO）</strong></p><ul><li>是一个接口或抽象类，借助注解定义数据库操作方法，如插入、查询、更新和删除等。</li><li>常见注解有 <code>@Insert</code>、<code>@Query</code>、<code>@Update</code> 和 <code>@Delete</code>。</li></ul></blockquote><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>导入配置文件</li><li>创建实体类Entity</li><li>创建DAO接口</li><li>创建数据库类Database</li><li>封装数据库与业务逻辑交互的Repository</li></ol><h3 id="创建实体类Entity"><a href="#创建实体类Entity" class="headerlink" title="创建实体类Entity"></a>创建实体类Entity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mvpdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.room.ColumnInfo;</span><br><span class="line"><span class="keyword">import</span> androidx.room.Entity;</span><br><span class="line"><span class="keyword">import</span> androidx.room.PrimaryKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description ： 用户的Entity</span></span><br><span class="line"><span class="comment"> * author : HI-IR</span></span><br><span class="line"><span class="comment"> * email : qq2420226433@outlook.com</span></span><br><span class="line"><span class="comment"> * date : 2025/1/23 19:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity(tableName = &quot;user_info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PrimaryKey(autoGenerate = true)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo(name = &quot;user_username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo(name = &quot;user_password&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>注解（常用）</strong></p><table><thead><tr><th align="left">序号</th><th align="left">注解名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">@Entity</td><td align="left">声明所标记的类是一个数据表，@Entity 包括的参数有：tableName(表名），indices（表的索引），primaryKeys（主键），foreignKeys（外键），ignoredColumns（忽略实体中的属性，不作为数据表中的字段），inheritSuperIndices（是否集成父类的索引，默认 false）</td></tr><tr><td align="left">2</td><td align="left">@ColumnInfo</td><td align="left">用来声明数据库中的字段名，参数：name(在数据库中的名字)</td></tr><tr><td align="left">3</td><td align="left">@PrimaryKey</td><td align="left">被修饰的属性作为数据表的主键，@PrimaryKey 包含一个参数：autoGenerate(是否允许自动创建，默认false)</td></tr><tr><td align="left">4</td><td align="left">@Embedded</td><td align="left">把一个实体类的字段嵌入到另一个实体类当中,有时一个实体可能包含多个相关联的子字段，而这些子字段可以归为一个独立的逻辑单元。通过使用 <code>@Embedded</code> 注解，能将这些子字段封装成一个单独的类，再嵌入到主实体类中，从而让代码结构更清晰，更易于维护</td></tr><tr><td align="left">5</td><td align="left">@Dao</td><td align="left">将类标记为数据访问对象（Data Access Object）</td></tr><tr><td align="left">6</td><td align="left">@Database</td><td align="left">将类标记为RoomDatabase</td></tr><tr><td align="left">7</td><td align="left">@Delete</td><td align="left">将 DAO 中的方法标记为与删除相关的方法</td></tr><tr><td align="left">8</td><td align="left">@Insert</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">@Update</td><td align="left"></td></tr><tr><td align="left">10</td><td align="left">@Query</td><td align="left"></td></tr></tbody></table></blockquote><h3 id="创建Dao（若有多个Entity应该写多个Dao）"><a href="#创建Dao（若有多个Entity应该写多个Dao）" class="headerlink" title="创建Dao（若有多个Entity应该写多个Dao）"></a>创建Dao（若有多个Entity应该写多个Dao）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@androidx</span>.room.Dao</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert</span><span class="comment">//增加</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">(UserEntity user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span><span class="comment">//修改</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(UserEntity user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span> <span class="comment">//删除</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(UserEntity user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(&quot;select user_password from user_info where user_username = :username&quot;)</span></span><br><span class="line">    String <span class="title function_">queryUserPassword</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“user_username &#x3D; :username””中的<code>:</code>是占位符</p></blockquote><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = &#123;UserEntity.class&#125;,version = 1,exportSchema = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">UserDatabase</span> <span class="keyword">extends</span> <span class="title class_">RoomDatabase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用</span></span><br><span class="line">userDatabase = Room.databaseBuilder(mContext, UserDatabase.class, <span class="string">&quot;user_database&quot;</span>).build();</span><br><span class="line">                userDao = userDatabase.getUserDao();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 寒假考核系列 </tag>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewPager2和BottomNavigationView的联动</title>
      <link href="/2025/01/20/ViewPager2%E5%92%8CBottomNavigationView%E7%9A%84%E8%81%94%E5%8A%A8/"/>
      <url>/2025/01/20/ViewPager2%E5%92%8CBottomNavigationView%E7%9A%84%E8%81%94%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ViewPager2和BottomNavigationView的联动"><a href="#ViewPager2和BottomNavigationView的联动" class="headerlink" title="ViewPager2和BottomNavigationView的联动"></a>ViewPager2和BottomNavigationView的联动</h1><h2 id="ViewPager2对BottomNavigationView的控制"><a href="#ViewPager2对BottomNavigationView的控制" class="headerlink" title="ViewPager2对BottomNavigationView的控制"></a>ViewPager2对BottomNavigationView的控制</h2><p>实现ViewPager2左右滑动控制BottomNavigationView的menu的控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mViewPager2.registerOnPageChangeCallback(......);<span class="comment">//检测Page的变化</span></span><br><span class="line">mBottomNavigationView.setSelectedItemId(R.id.xxx)<span class="comment">//设置BottomNavigationView的menu被选中的选项</span></span><br></pre></td></tr></table></figure><ul><li><strong>实例</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ViewPager2.registerOnPageChangeCallback(<span class="keyword">new</span> <span class="title class_">ViewPager2</span>.OnPageChangeCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPageScrolled</span><span class="params">(<span class="type">int</span> position, <span class="type">float</span> positionOffset, <span class="type">int</span> positionOffsetPixels)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.onPageScrolled(position, positionOffset, positionOffsetPixels);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当页面被选择时</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPageSelected</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.onPageSelected(position);</span><br><span class="line">                onPagerSelected(position);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPageScrollStateChanged</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.onPageScrollStateChanged(state);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPagerSelected</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (position)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">                mBottomNavigationView.setSelectedItemId(R.id.menu_xxx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">                mBottomNavigationView.setSelectedItemId(R.id.menu_xxx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">                mBottomNavigationView.setSelectedItemId(R.id.menu_xxx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="BottomNavigationView对ViewPager2的控制"><a href="#BottomNavigationView对ViewPager2的控制" class="headerlink" title="BottomNavigationView对ViewPager2的控制"></a>BottomNavigationView对ViewPager2的控制</h2><p>实现BottomNavigationView的menu点击控制ViewPager2翻页</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mBottomNavigationView.setOnNavigationItemSelectedListener(...);<span class="comment">//监听menu的点击</span></span><br><span class="line">mViewPager.setCurrentItem(<span class="type">int</span> Index);<span class="comment">//设置ViewPager2的页数</span></span><br></pre></td></tr></table></figure><ul><li><strong>实例</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mBottomNavigationView.setOnNavigationItemSelectedListener(<span class="keyword">new</span> <span class="title class_">BottomNavigationView</span>.OnNavigationItemSelectedListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onNavigationItemSelected</span><span class="params">(<span class="meta">@NonNull</span> MenuItem item)</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (item.getItemId())&#123;</span><br><span class="line">                    <span class="keyword">case</span> R.id.xxx:&#123;</span><br><span class="line">                        mVp2.setCurrentItem(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> R.id.xxx:&#123;</span><br><span class="line">                        mVp2.setCurrentItem(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> R.id.xxx:&#123;</span><br><span class="line">                        mVp2.setCurrentItem(<span class="number">2</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">default</span>:&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 寒假考核系列 </tag>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BottomNavigationView</title>
      <link href="/2025/01/20/BottomNavigationView/"/>
      <url>/2025/01/20/BottomNavigationView/</url>
      
        <content type="html"><![CDATA[<h1 id="BottomNavigationView"><a href="#BottomNavigationView" class="headerlink" title="BottomNavigationView"></a>BottomNavigationView</h1><h2 id="导入新包"><a href="#导入新包" class="headerlink" title="导入新包"></a>导入新包</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.google.android.material:material:1.4.0&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><ul><li>底部导航栏的背景颜色,默认是主题的颜色</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:iteamBackground=&quot;&quot;</span><br></pre></td></tr></table></figure><ul><li>底部导航栏中icon的颜色</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:itemIconTint=&quot;&quot;</span><br></pre></td></tr></table></figure><blockquote><p>可以设置成一个selector来实现被选择与没被选中不同颜色</p></blockquote><ul><li>底部导航栏文字的颜色</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:itemTextColor=&quot;&quot;</span><br></pre></td></tr></table></figure><blockquote><p>可以设置成一个selector来实现被选择与没被选中不同颜色</p></blockquote><ul><li>标签可见性设置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:labelVisibilityMode=&quot;&quot;</span><br></pre></td></tr></table></figure><blockquote><ul><li>labeled：图标和文字都显示</li><li>selected：选择时显示文字</li><li>auto：</li><li>unlabeled：文字不显示</li></ul></blockquote><ul><li><p>auto的显示效果和<code>isShifting</code>有关</p></li><li><p>当<code>isShifting=true</code>时，auto和selected显示效果一样</p></li><li><p>当<code>isShifting=false</code>时，auto和labeled显示效果一样</p></li><li><p>字体的style设置</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app:itemTextAppearanceActive=&quot;@style/selectText&quot;<span class="comment">&lt;!--选中字体大小风格--&gt;</span></span><br><span class="line">app:itemTextAppearanceInactive=&quot;@style/unSelectText&quot;<span class="comment">&lt;!--未选中字体大小风格--&gt;</span></span><br></pre></td></tr></table></figure><p>可以在<code>@style/selectText</code>中设置字体的大小</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;selectText&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textSize&quot;</span>&gt;</span>20sp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:drawablePadding&quot;</span>&gt;</span>8dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;unSelectText&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textSize&quot;</span>&gt;</span>14sp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:drawablePadding&quot;</span>&gt;</span>4dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>菜单布局</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:menu=&quot;&quot;</span><br></pre></td></tr></table></figure><ul><li>水波纹效果(app:itemRippleColor)</li></ul><p><code>app:itemBackground</code> 和<code>app:itemRippleColor</code>都是设置给到导航栏的背景,如果要设置水波纹有有效果,那么必须不设置背景</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app:itemBackground=&quot;@null&quot;</span><br><span class="line">app:itemRippleColor=&quot;@color/design_default_color_primary&quot;</span><br></pre></td></tr></table></figure><h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><h3 id="设置点击事件"><a href="#设置点击事件" class="headerlink" title="设置点击事件"></a>设置点击事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BottomNavigationView.OnNavigationItemSelectedListener();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 寒假考核系列 </tag>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ToolBar控件</title>
      <link href="/2025/01/20/ToolBar%E6%8E%A7%E4%BB%B6/"/>
      <url>/2025/01/20/ToolBar%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="ToolBar控件"><a href="#ToolBar控件" class="headerlink" title="ToolBar控件"></a>ToolBar控件</h1><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;?android:attr/actionBarSize&quot;</span>//<span class="attr">工具条高度和界面保持一致</span>(<span class="attr">默认56dp</span>)</span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>背景色</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:background=&quot;&quot;</span><br></pre></td></tr></table></figure><ul><li>左侧图标</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:navigationIcon=&quot;&quot;</span><br></pre></td></tr></table></figure><ul><li>主标题</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:title=&quot;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:titleTextColor=&quot;&quot;<span class="comment">&lt;!--改字体颜色--&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在ToolBar里面设置的主标题不能修改字体大小，文字居中等，所以我们一般可以在Toolbar中嵌套一个TextView来做标题</p></blockquote><ul><li>标题和图标的间距</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:titleMarginStart=&quot;&quot;</span><br></pre></td></tr></table></figure><ul><li>子标题</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:subtitle=&quot;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:subtitleTextColor=&quot;&quot; <span class="comment">&lt;!--字体颜色--&gt;</span></span><br></pre></td></tr></table></figure><ul><li>logo</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:logo=&quot;&quot;</span><br></pre></td></tr></table></figure><ul><li>右侧折叠菜单</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:menu=&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><ul><li>左侧图标的点击事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setNavigationOnClickListener(OnClickListener listener)设置点击导航按钮监听</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 寒假考核系列 </tag>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DrawerLayout-NavigationView实现滑动菜单</title>
      <link href="/2025/01/19/DrawerLayout-NavigationView%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E8%8F%9C%E5%8D%95/"/>
      <url>/2025/01/19/DrawerLayout-NavigationView%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E8%8F%9C%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="DrawerLayout-NavigationView实现滑动菜单"><a href="#DrawerLayout-NavigationView实现滑动菜单" class="headerlink" title="DrawerLayout-NavigationView实现滑动菜单"></a>DrawerLayout-NavigationView实现滑动菜单</h1><h2 id="DrawerLayout"><a href="#DrawerLayout" class="headerlink" title="DrawerLayout"></a>DrawerLayout</h2><h3 id="DrawerLayout介绍"><a href="#DrawerLayout介绍" class="headerlink" title="DrawerLayout介绍"></a>DrawerLayout介绍</h3><p> DrawerLayout 提供了一种简单而直观的方式来让用户访问应用的不同部分或功能模块</p><blockquote><p><code>DrawerLayout</code> 是 Android 中用于实现侧边导航栏的一个重要组件。</p></blockquote><h3 id="DrawerLayout的实现"><a href="#DrawerLayout的实现" class="headerlink" title="DrawerLayout的实现"></a>DrawerLayout的实现</h3><h4 id="XML布局"><a href="#XML布局" class="headerlink" title="XML布局"></a>XML布局</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.drawerlayout.widget.DrawerLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/drawer_layout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 主屏幕显示内容--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;140dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;这是主屏幕&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;打开左侧菜单&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 侧滑显示内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;260dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;left&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#BCEE68&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center_horizontal&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;这是侧滑显示&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.drawerlayout.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>主视图的 <code>layout_height</code> 必须是 <code>match_parent</code>，否则报错。</p><p>侧滑菜单关键属性<code>android:layout_gravity</code>，这个是必须要指定的。(left即为左侧侧滑菜单，right即为右侧侧滑菜单)</p></blockquote><p> 这里只是一个简单的实现，你可以把 <code>TextView</code> 改为 <code>NavigationView 或自定义布局</code>。</p><h4 id="DrawerLayout的交互"><a href="#DrawerLayout的交互" class="headerlink" title="DrawerLayout的交互"></a>DrawerLayout的交互</h4><h5 id="打开侧边栏"><a href="#打开侧边栏" class="headerlink" title="打开侧边栏"></a>打开侧边栏</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawerLayout.openDrawer()</span><br></pre></td></tr></table></figure><p>通过按钮或手势调用 <code>drawerLayout.openDrawer()</code> 方法，将滑动菜单显示出来，注意 <code>openDrawer</code> 方法需要传入一个<code>Gravity</code>参数。需要和XML文件设置的 <code>layout_gravity</code> 方向保持统一，否则会报错</p><h5 id="关闭侧边栏"><a href="#关闭侧边栏" class="headerlink" title="关闭侧边栏"></a>关闭侧边栏</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawerLayout.closeDrawer();</span><br></pre></td></tr></table></figure><p>通过按钮或手势调用 <code>drawerLayout.closeDrawer()</code> 方法，将滑动菜单显示出来，注意 <code>closeDrawer</code> 方法需要传入一个<code>Gravity</code>参数。需要和XML文件设置的 <code>layout_gravity</code> 方向保持统一，否则会报错</p><h5 id="侧边栏的监听"><a href="#侧边栏的监听" class="headerlink" title="侧边栏的监听"></a>侧边栏的监听</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawerLayout.addDrawerListener();</span><br></pre></td></tr></table></figure><p>通过<code>addDrawerListener</code>方法监听侧边栏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">drawerLayout.addDrawerListener(<span class="keyword">new</span> <span class="title class_">DrawerLayout</span>.DrawerListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDrawerSlide</span><span class="params">(<span class="meta">@NonNull</span> View drawerView, <span class="type">float</span> slideOffset)</span> &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDrawerOpened</span><span class="params">(<span class="meta">@NonNull</span> View drawerView)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDrawerClosed</span><span class="params">(<span class="meta">@NonNull</span> View drawerView)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDrawerStateChanged</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h2 id="NavigationView"><a href="#NavigationView" class="headerlink" title="NavigationView"></a>NavigationView</h2><h3 id="NavigationView介绍"><a href="#NavigationView介绍" class="headerlink" title="NavigationView介绍"></a>NavigationView介绍</h3><p>根据上面内容已经成功实现了侧滑菜单的功能，但是侧滑菜单的UI比较单一。但真正的侧滑菜单可不会这么简单,如何丰富我们的侧滑菜单呢？</p><p>有2种解决途径</p><blockquote><ul><li>1.在侧滑菜单中自定义布局</li><li>2.Google 提供的 NavigationView(推荐使用)。</li></ul></blockquote><p>这个菜单整体上分为两部分，上面一部分叫做<code>HeaderLayout</code>，下面的那些点击项都是<code>menu</code></p><h3 id="NavigationView属性"><a href="#NavigationView属性" class="headerlink" title="NavigationView属性"></a>NavigationView属性</h3><ul><li><p><code>app:headerLayout=&quot;@layout/header_layout</code>:引用一个头布局文件，这个头就是我们在上面看到的那个背景图片，包括背景图片上面的显示用户名的控件等等</p></li><li><p><code>app:menu=&quot;@menu/menu&quot;</code>表示引用一个menu作为下面的点击项</p></li><li><p><code>app:itemIconTint=&quot;@color/blue&quot;</code>可以设置menu中item的icon颜色</p></li></ul><blockquote><p>如果要使用icon原本的颜色，可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> <span class="variable">navigationView</span> <span class="operator">=</span>findViewById(R.id.navigation_view);</span><br><span class="line">navigationView.setItemIconTintList(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><code>app:itemBackground=&quot;@color/colorAccent&quot;</code>设置每一个item的背景颜色</p><p><code>app:itemTextColor=&quot;&quot;</code>设置item的背景颜色</p></li><li><p>如果我想在NavigationView的item之间添加上一条分隔线呢？</p><p>只需要在<code>menu</code>中将相应的<code>item</code>放到一个<code>group</code>中，并给该group取一个id即可</p></li></ul><h3 id="NavigationView的事件监听"><a href="#NavigationView的事件监听" class="headerlink" title="NavigationView的事件监听"></a>NavigationView的事件监听</h3><h4 id="头部点击事件"><a href="#头部点击事件" class="headerlink" title="头部点击事件"></a>头部点击事件</h4><p>处理头部点击事件，我们需要先获得到头部控件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取头布局文件</span></span><br><span class="line"><span class="type">View</span> <span class="variable">headerView</span> <span class="operator">=</span> navigationView.getHeaderView(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>然后通过调用headerView中的findViewById方法来查找到头部的控件，设置点击事件即可。</p><h4 id="item点击事件"><a href="#item点击事件" class="headerlink" title="item点击事件"></a>item点击事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">navigationView.setNavigationItemSelectedListener(<span class="keyword">new</span> <span class="title class_">NavigationView</span>.OnNavigationItemSelectedListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onNavigationItemSelected</span><span class="params">(<span class="meta">@NonNull</span> MenuItem menuItem)</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (menuItem.getItemId()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> R.id.title1:</span><br><span class="line">                        Toast.makeText(Main2Activity.<span class="built_in">this</span>, <span class="string">&quot;第一个&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 寒假考核系列 </tag>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假考核Day1</title>
      <link href="/2025/01/18/%E5%AF%92%E5%81%87%E8%80%83%E6%A0%B8Day1/"/>
      <url>/2025/01/18/%E5%AF%92%E5%81%87%E8%80%83%E6%A0%B8Day1/</url>
      
        <content type="html"><![CDATA[<h1 id="寒假考核Day1"><a href="#寒假考核Day1" class="headerlink" title="寒假考核Day1"></a>寒假考核Day1</h1><p>今日完成：</p><ul><li><input checked="" disabled="" type="checkbox"> 学习MVP架构</li><li><input checked="" disabled="" type="checkbox"> 进行MVP架构的小练习</li><li><input checked="" disabled="" type="checkbox"> 完成了基础的软件规划</li><li><input checked="" disabled="" type="checkbox"> 完成了基础的登录功能</li><li><input checked="" disabled="" type="checkbox"> 完成了NetUtils工具类的编写</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 寒假考核系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVP架构</title>
      <link href="/2025/01/18/MVP%E6%9E%B6%E6%9E%84/"/>
      <url>/2025/01/18/MVP%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="MVP架构"><a href="#MVP架构" class="headerlink" title="MVP架构"></a>MVP架构</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>三个核心组件组成：Model（模型）、View（视图）和 Presenter（展示器）</p><p>把原来的UI逻辑抽象成View接口，把原来的业务逻辑抽象成Presenter接口，model还是原来的modle</p><blockquote><p><strong>Model（模型）</strong>：</p><ul><li>**定义:**负责处理应用程序的数据逻辑，包括与数据库、网络、API等数据源的交互</li><li>**职责:**提供数据，并将其返回给 Presenter，不涉及任何UI相关逻辑</li></ul><p><strong>View（视图）</strong>：</p><ul><li><p>**定义:**负责展示用户界面，接收用户的输入并将其传递给 Presenter</p></li><li><p>**职责:**展示由 Presenter 提供的数据，并根据用户操作调用 Presenter 的方法。View 层不直接处理逻辑，只展示内容</p></li></ul><p><strong>Presenter（演示者）</strong>：</p><ul><li><p>**定义：**作为 View 和 Model 之间的桥梁，负责处理逻辑和协调数据流</p></li><li><p><strong>职责：</strong></p><ol><li>从 View 接收用户输入，调用 Model 获取数据</li><li>将数据处理结果返回给 View 以更新UI</li><li>Presenter 不直接操作UI，而是通过接口与 View 进行交互</li></ol></li></ul></blockquote><h2 id="交互流程"><a href="#交互流程" class="headerlink" title="交互流程"></a>交互流程</h2><p>用户操作触发——&gt;Presenter 处理——&gt;Model 数据处理——&gt;Presenter 更新 View</p><h2 id="案例：简单登录页"><a href="#案例：简单登录页" class="headerlink" title="案例：简单登录页"></a>案例：简单登录页</h2><ul><li><h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3></li></ul><p>为了保证Presenter与View和Model解耦，我们需要为View和Model定义接口</p><p><strong>ILoginView:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILoginView</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showLoging</span><span class="params">()</span>;<span class="comment">//加载条</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hideLoading</span><span class="params">()</span>;<span class="comment">//隐藏加载条</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showLoginInf</span><span class="params">(String msg)</span>;<span class="comment">//显示登录信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ILoginModel:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILoginModel</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String usename,String password,Callback callback)</span>;<span class="comment">//数据判断逻辑</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String msg)</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(String msg)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="实现Model和Presenter"><a href="#实现Model和Presenter" class="headerlink" title="实现Model和Presenter"></a>实现Model和Presenter</h3></li></ul><p><strong>LoginModel</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginModel</span> <span class="keyword">implements</span> <span class="title class_">ILoginModel</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String usename, String password, Callback callback)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (usename.equals(<span class="string">&quot;admin&quot;</span>) &amp;&amp; password.equals(<span class="string">&quot;1234&quot;</span>))&#123;</span><br><span class="line">            callback.onSuccess(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            callback.onError(<span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>LoginPresenter</strong></p><blockquote><p>Presenter像一个人一样，左手牵View层，右手牵Model层</p></blockquote><ol><li>构建View层与Presenter和Model层和Presenter层的联系</li></ol><p><em>如图：</em> <img src="/../image/MVP%E6%9E%B6%E6%9E%84/1.jpg" alt="1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginPresenter</span>&lt;T <span class="keyword">extends</span> <span class="title class_">ILoginView</span>&gt; &#123;</span><br><span class="line">    <span class="comment">//-------------构建View层与Presenter和Model层和Presenter层的联系---------------</span></span><br><span class="line">    ILoginView mLoginView;</span><br><span class="line">    <span class="type">ILoginModel</span> <span class="variable">mLoginModel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginModel</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginPresenter</span><span class="params">(T View)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mLoginView = View;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------业务逻辑-----------------------------------</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">        mLoginView.showLoging();</span><br><span class="line">        mLoginModel.login(username, password, <span class="keyword">new</span> <span class="title class_">ILoginModel</span>.Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">                mLoginView.hideLoading();</span><br><span class="line">                mLoginView.showLoginInf(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">                mLoginView.hideLoading();</span><br><span class="line">                mLoginView.showLoginInf(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="View层实现"><a href="#View层实现" class="headerlink" title="View层实现"></a>View层实现</h3></li></ul><p>最后，我们在View层中实现ILoginView接口，并将操作委托给Presenter层</p><p><strong>LoginActivity：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">ILoginView</span> &#123;</span><br><span class="line">    EditText mEtUserName;</span><br><span class="line">    EditText mEtPassWord;</span><br><span class="line">    Button mBtnLogin;</span><br><span class="line">    ProgressBar mProgressBar;</span><br><span class="line">    LoginPresenter mLoginPresenter;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_login);</span><br><span class="line">        initview();</span><br><span class="line">        initEvent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initview</span><span class="params">()</span> &#123;</span><br><span class="line">        mEtPassWord=findViewById(R.id.password);</span><br><span class="line">        mEtUserName=findViewById(R.id.username);</span><br><span class="line">        mBtnLogin=findViewById(R.id.loginButton);</span><br><span class="line">        mProgressBar=findViewById(R.id.progressBar);</span><br><span class="line">        mLoginPresenter=<span class="keyword">new</span> <span class="title class_">LoginPresenter</span>(<span class="built_in">this</span>);<span class="comment">//创建Presenter层</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        mBtnLogin.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                showLoging();</span><br><span class="line">               mLoginPresenter.login(mEtUserName.getText().toString(),mEtPassWord.getText().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showLoging</span><span class="params">()</span> &#123;</span><br><span class="line">        mProgressBar.setVisibility(View.VISIBLE);</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>,<span class="string">&quot;登录中&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hideLoading</span><span class="params">()</span> &#123;</span><br><span class="line">        mProgressBar.setVisibility(View.GONE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showLoginInf</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>,msg,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xxxxxxxxxx11 1navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {2            @Override3            public boolean onNavigationItemSelected(@NonNull MenuItem menuItem) {4                switch (menuItem.getItemId()) {5                    case R.id.title1:6                        Toast.makeText(Main2Activity.this, “第一个”, Toast.LENGTH_SHORT).show();7                        break;8                }9                return true;10            }11        });java</p><p><strong>activity_login.xml：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;16dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用户名输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/username&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;Username&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:inputType</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">&quot;12dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;16dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 密码输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/password&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;Password&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:inputType</span>=<span class="string">&quot;textPassword&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">&quot;12dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;16dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 登录按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/loginButton&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Login&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">&quot;12dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;16dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载进度条 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ProgressBar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/progressBar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">&quot;gone&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li></ul><p>​<img src="/../image/MVP%E6%9E%B6%E6%9E%84/2.jpg" alt="2"></p><p><strong>代码逻辑</strong></p><ol><li>用户在 <code>LoginActivity</code> 中输入用户名和密码，并点击登录按钮。</li><li><code>LoginActivity</code> 通过 <code>LoginPresenter</code> 调用 <code>login</code> 方法，传递用户名和密码。</li><li><code>LoginPresenter</code> 调用 <code>LoginView</code> 的 <code>showLoading</code> 方法显示加载状态。</li><li><code>LoginPresenter</code> 调用 <code>LoginModel</code> 的 <code>login</code> 方法，并传递用户名、密码和 <code>LoginCallback</code> 实例。</li><li><code>LoginModelImpl</code> 进行登录验证，如果成功，调用 <code>LoginCallback</code> 的 <code>onSuccess</code> 方法；如果失败，调用 <code>onError</code> 方法。</li><li><code>LoginPresenter</code> 收到回调结果，调用 <code>LoginView</code> 的 <code>hideLoading</code> 方法隐藏加载状态，并根据结果调用 <code>LoginView</code> 的 <code>showLoginInf</code> 方法</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 寒假考核系列 </tag>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL指令</title>
      <link href="/2025/01/17/SQL%E6%8C%87%E4%BB%A4/"/>
      <url>/2025/01/17/SQL%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL指令"><a href="#SQL指令" class="headerlink" title="SQL指令"></a>SQL指令</h1><blockquote><p>可以使用SQL命令进行关系型数据库操作</p></blockquote><blockquote><p><strong>注:</strong> 不同的关系型管理系统可能有不同的指令</p></blockquote><p><strong>持续更新(学到哪更到哪)</strong></p><h2 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h2><blockquote><p>SQL指令主要分为：数据定义，数据操纵，数据查询，数据控制，事务控制等</p></blockquote><h3 id="数据定义-DDL"><a href="#数据定义-DDL" class="headerlink" title="数据定义(DDL)"></a>数据定义(DDL)</h3><p>​创建和修改盛放数据的容器</p><h3 id="数据操纵-DML"><a href="#数据操纵-DML" class="headerlink" title="数据操纵(DML)"></a>数据操纵(DML)</h3><p>​表中添加，修改，删除数据</p><h3 id="数据查询-DQL"><a href="#数据查询-DQL" class="headerlink" title="数据查询(DQL)"></a>数据查询(DQL)</h3><p>​表中数据多条件查询（最复杂的！！！）</p><h3 id="事务控制-TCL-与-数据控制-DCL"><a href="#事务控制-TCL-与-数据控制-DCL" class="headerlink" title="事务控制(TCL) 与 数据控制(DCL)"></a>事务控制(TCL) 与 数据控制(DCL)</h3><p>​事务启动，提交，回滚(事务控制)</p><p>​账号创建，权限控制(数据控制)</p><p><strong>注：</strong> 数据定义，数据操纵，数据查询是重点</p><blockquote><p><strong>学习路线</strong> DDL - DML - DQL  - TCL - DCL</p></blockquote><h3 id="一条数据的存储过程"><a href="#一条数据的存储过程" class="headerlink" title="一条数据的存储过程"></a>一条数据的存储过程</h3><p>创建库 -&gt; 定字段 -&gt; 创建表 -&gt; 插数据</p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="连接mysql服务"><a href="#连接mysql服务" class="headerlink" title="连接mysql服务"></a>连接mysql服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u&lt;username&gt; -p&lt;password&gt; -h&lt;hostname&gt; -P&lt;port&gt; &lt;databassname&gt;</span><br></pre></td></tr></table></figure><blockquote><p>-u<username>：用户名 </p><p>-p<password>：密码（-p后面不带空格 例：-ppassword）</p><p>-h<hostname>：用于指定MySQL服务器的IP（可以不写该参数，默认本地）</p><p>-P<port>：用于指定链接MySQL服务器的端口号（可不写，默认3306）</p><p><databassname>：是你要连接的数据库的名字，连接后会默认使用这个数据库</p></blockquote><p><strong>也可以在-p后不输入密码，进入隐私模式输入密码</strong></p><h3 id="其他基础SQL命令"><a href="#其他基础SQL命令" class="headerlink" title="其他基础SQL命令"></a>其他基础SQL命令</h3><blockquote><p>命令之间用  ;  隔开</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查看版本</span><br><span class="line"><span class="keyword">select</span> version();</span><br><span class="line"></span><br><span class="line">-- 退出连接</span><br><span class="line"><span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure><h2 id="SQL命名规定和规范"><a href="#SQL命名规定和规范" class="headerlink" title="SQL命名规定和规范"></a>SQL命名规定和规范</h2><h3 id="SQL命名规定"><a href="#SQL命名规定" class="headerlink" title="SQL命名规定"></a>SQL命名规定</h3><ol><li>数据库名，表名不得超过30个字符，变量名限制为29个</li><li>必须只能包含A<del>Z，a</del>z，0~9，_ ，且<strong>不能以数字</strong>开头</li><li>数据库名，表，字段等对象名中<strong>不能</strong>包含空格</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li><li>字段没有和保留字，数据库关键字重名。如果非要用，请在SQL语句中使用 “ &#96; ” 标识</li></ol><h3 id="SQL命名规范"><a href="#SQL命名规范" class="headerlink" title="SQL命名规范"></a>SQL命名规范</h3><ol><li>库，表，列名应该使用小写字母，并使用**下划线(_)**或者使用驼峰命名法</li><li>库名应于对应的程序名一致。例如：程序名为 EcommercePlatform 数据库名命名为 ecommerce_platform</li><li>表命名最好是遵循 **”业务名称_表的作用”**的方式 例如：trade_config</li><li>列名应该遵循 **”表实体_属性“**的方式 例如：product_name 或者 productName</li></ol><h2 id="数据定义DDL"><a href="#数据定义DDL" class="headerlink" title="数据定义DDL"></a>数据定义DDL</h2><blockquote><p>定义和管理数据库的结构，完成<strong>库</strong> ，<strong>表</strong>，索引，视图等数据库对象的创建，修改和删除。</p><p>DDL不涉及对数据的操作，而是关注数据库的结构和元数据（容器）。</p></blockquote><h3 id="DDL关键字"><a href="#DDL关键字" class="headerlink" title="DDL关键字"></a>DDL关键字</h3><p><strong>CREATE</strong> :用于创建数据库，表，索引，视图</p><p><strong>ALTER</strong>:用于修改数据库对象的结构，如修改表结构，添加列，和删除列等</p><p><strong>DROP</strong>:用于删除数据库对象，如删除表，删除索引等</p><h3 id="库管理"><a href="#库管理" class="headerlink" title="库管理"></a>库管理</h3><h4 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h4><p>创建库，必须指定<strong>库名</strong>，可能指定<strong>字符集</strong>或者<strong>排序方式</strong></p><ul><li>方式1：创建数据库，使用默认的字符集和排序方式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果存在该数据库则会报错</p><ul><li>方式2：判断并创建默认字符集数据库（推荐）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABAsE IF NOT EXISTS 数据库名;</span><br></pre></td></tr></table></figure><ul><li>方式3：创建指定字符集和排序规则库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名 CHARACTER SET 字符集 COLLATE 排序规则;</span><br></pre></td></tr></table></figure><blockquote><p>字符集：即编码格式，如果不采用正确的字符集则可能出现乱码的情况</p><p>(字符集Character Set：utf8<strong>utf8mb4</strong>)</p><p>排序规则：如何比较和排序存储在数据库中的文本数据</p><p>(排序规则Collate：utf8mb4_0900_ai_ci:不区分大小写；utf8mb4_0900_as_cs:区分大小写)</p></blockquote><h4 id="查看和使用库"><a href="#查看和使用库" class="headerlink" title="查看和使用库"></a>查看和使用库</h4><ul><li>查看当前所有库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br><span class="line"># 注意有S</span><br></pre></td></tr></table></figure><ul><li>查看当前使用的库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure><ul><li>查看创建库的信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE DATABASE 数据库名;</span><br></pre></td></tr></table></figure><ul><li>查看指定库下所有表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES FROM 数据库名;</span><br><span class="line"># 注意table有S</span><br></pre></td></tr></table></figure><ul><li>切换库和选中库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure><hr><p><strong>注意:</strong></p><ol><li>当查看所有表，所有库的时候会加S，如DATABASES，TABLES</li><li>要操控表格和数据之前必须先说明是对哪个数据库进行操作，先use库</li></ol><hr><h4 id="修改库"><a href="#修改库" class="headerlink" title="修改库"></a>修改库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE 数据库名 CHARACTER SET 字符集 COLLATE 排序方式</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：修改库只能修改库的字符集和排序方式，不能修改数据库名字。</p><p><em>一些可视化工具可以给库改名：它是建新库，把所有表复制到新库，再把就库删除</em></p><h4 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h4><blockquote><p>删除数据库前要三思，确认好再删除，否则真要 提桶跑路.jpg</p></blockquote><ul><li>直接删库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE 数据库名;</span><br><span class="line"># 如果库名不存在则报错</span><br></pre></td></tr></table></figure><ul><li>判读并删除库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS 数据库名;</span><br></pre></td></tr></table></figure><h3 id="表管理"><a href="#表管理" class="headerlink" title="表管理"></a>表管理</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> [if <span class="keyword">not</span> <span class="keyword">exists</span>] 表名(</span><br><span class="line">列名 类型 [列可选约束][commnet <span class="string">&#x27;列注释&#x27;</span>],</span><br><span class="line">列名 类型 [列可选约束][commnet <span class="string">&#x27;列注释&#x27;</span>],</span><br><span class="line"> 列名 类型 [列可选约束][commnet <span class="string">&#x27;列注释&#x27;</span>],</span><br><span class="line">    [列可选约束]</span><br><span class="line">)[表可选约束][commnet <span class="string">&#x27;表注释&#x27;</span>];</span><br></pre></td></tr></table></figure><p>核心要素：表名，列名，列类型</p><p>可选要素：指定列约束，指定表配置，指定表列注释</p><p>列之间用 “ , “隔开</p><p><em>“[]” 表示可选</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL学习 </tag>
            
            <tag> 寒假考核系列 </tag>
            
            <tag> 安卓学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础之集合</title>
      <link href="/2025/01/08/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88/"/>
      <url>/2025/01/08/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="为什么使用泛型"><a href="#为什么使用泛型" class="headerlink" title="为什么使用泛型"></a>为什么使用泛型</h2><blockquote><p>泛型是一种推广化和限制化</p><p>泛型是一种<strong>推广化</strong>。它允许代码在更广泛的类型上工作，而不是局限于特定的类型</p><p>泛型是一种<strong>限制化</strong>。通过指定泛型类型，限制了在该类型参数位置可以使用的类型</p></blockquote><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><h3 id="泛型类的定义"><a href="#泛型类的定义" class="headerlink" title="泛型类的定义"></a>泛型类的定义</h3><blockquote><p>类型参数用于类的定义中，则该类被称为泛型类。</p><p>最典型的就是各种容器类，如：List、Set、Map等。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 类名&lt;泛型标识&gt;&#123;</span><br><span class="line"><span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> 变量名; </span><br><span class="line">  .....</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>常见的泛型标识如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T ：代表一般的任何类。</span><br><span class="line">E ：代表 Element 元素的意思，或者 Exception 异常的意思。</span><br><span class="line">K ：代表 Key 的意思。</span><br><span class="line">V ：代表 Value 的意思，通常与 K 一起配合使用。</span><br></pre></td></tr></table></figure></blockquote><p>**注意：**泛型是没有多态的</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="Java集合分为2种体系"><a href="#Java集合分为2种体系" class="headerlink" title="Java集合分为2种体系"></a>Java集合分为2种体系</h3><ol><li>单一数据体系: Collection接口</li><li>成对出现的数据体系     键值对数据（key , value） Map接口</li></ol><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>​按照插入顺序保存数据，数据可以重复</p><p>​具体实现类：ArrayListLinkedList</p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure><ol><li>参数构造，底层数组为空数组</li><li>构造函数传递一个int类型的数据，用于设定底层数组的长度</li><li>构造函数传递一个Collection集合类型的值，用于将其他集合中的数据放置在当前集合中</li></ol><h5 id="增"><a href="#增" class="headerlink" title="增"></a>增</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Object element)</span>;</span><br><span class="line"><span class="comment">//在集合最后面加入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index,Object element)</span></span><br><span class="line"><span class="comment">//在指定位置插入元素</span></span><br></pre></td></tr></table></figure><p>*注意扩容</p><h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">removeVal</span> <span class="operator">=</span> list.remove(<span class="type">int</span> index);</span><br><span class="line"><span class="comment">//该方法返回结果，这个结果是删除的值</span></span><br></pre></td></tr></table></figure><h5 id="改"><a href="#改" class="headerlink" title="改"></a>改</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">oldVal</span> <span class="operator">=</span>list.set(<span class="type">int</span> index,Object element);</span><br><span class="line"><span class="comment">//该方法返回结果，这个结果是更新前的值</span></span><br></pre></td></tr></table></figure><h5 id="查"><a href="#查" class="headerlink" title="查"></a>查</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问数组长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定位置的数据</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure><h5 id="其他常用方法"><a href="#其他常用方法" class="headerlink" title="其他常用方法"></a>其他常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//集合中的数据是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//清空集合中的数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt;c)</span>;</span><br><span class="line"><span class="comment">//删除指定集合的数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object element)</span>;</span><br><span class="line"><span class="comment">//集合中是否存在元素element</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexof</span><span class="params">(Object element)</span>;</span><br><span class="line"><span class="comment">//用于获取数据在集合中第一个索引位置</span></span><br><span class="line"><span class="comment">//如果数据不存在，则返回-1</span></span><br><span class="line"><span class="comment">//如果有2个同样的element，则返回第一个索引</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Object[] toArray();</span><br><span class="line"><span class="comment">//把ArrayList变成Array数组</span></span><br><span class="line"></span><br><span class="line">Object <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//克隆ArrayList</span></span><br></pre></td></tr></table></figure><h4 id="LinkedList-双向链表"><a href="#LinkedList-双向链表" class="headerlink" title="LinkedList(双向链表)"></a>LinkedList(双向链表)</h4><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="comment">//有参构造 传入一个Collection数据</span></span><br></pre></td></tr></table></figure><h5 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Object element)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index,Object element)</span>;</span><br><span class="line"><span class="comment">//插入法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Object element)</span>;</span><br></pre></td></tr></table></figure><h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//获取头指针指向的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//获取尾指针指向的元素</span></span><br><span class="line"></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure><h5 id="改-1"><a href="#改-1" class="headerlink" title="改"></a>改</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,Object element)</span>;</span><br></pre></td></tr></table></figure><h5 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">remove</span><span class="params">()</span>;<span class="comment">//删除第一个</span></span><br><span class="line"></span><br><span class="line">E <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object element)</span></span><br></pre></td></tr></table></figure><h5 id="其他常用方法-1"><a href="#其他常用方法-1" class="headerlink" title="其他常用方法"></a>其他常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object element)</span>;</span><br><span class="line"><span class="comment">//等同于 list.addFirst()</span></span><br><span class="line"></span><br><span class="line">E <span class="title function_">pop</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//弹出数据</span></span><br></pre></td></tr></table></figure><h4 id="排序（sort）"><a href="#排序（sort）" class="headerlink" title="排序（sort）"></a>排序（sort）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt; &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1,Integer o2)</span>&#123;</span><br><span class="line">        <span class="comment">//如果第一个数比第二个数大，则返回结果为正数，标识升序</span></span><br><span class="line">        <span class="comment">//如果第一个数比第二个数小，则返回结果为负数，标识降序</span></span><br><span class="line">        <span class="comment">//如果第一个数比第二个数相等，则返回结果0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.sort();</span><br><span class="line"><span class="comment">//需要传入一个实现了比较器Comparator接口的对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Comparator比较器中compare的规则"><a href="#Comparator比较器中compare的规则" class="headerlink" title="Comparator比较器中compare的规则"></a>Comparator比较器中compare的规则</h5><p>**规则:**返回结果为正时，交换顺序，返回值为负时不交换顺序</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>​集，无顺保存，数据不能重复</p><p>​具体实现类：HashSet</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>放入的数据会通过Hash算法得到不同的index，我们并不能知道一个element对应的经过Hash算法后的index，所以对于我们而言是无序的，相同的element经过Hash得到的index是一样的，HashSet所以数据是不能重复的</p><p>添加一个数据时，先经过Hash算法获得index,按照index放入相对应的数组位置中，如果2个不相同的元素，经过该算法获得了相同的index那么HashSet将会运行equal来判断2个元素是否相等，相等则不改变set，不相等时会采用链表的方法将2值连在一起</p><p><strong>HashSet的底层为 数组+链表的形式</strong></p><blockquote><p><strong>对象重复的判断标准：</strong></p><p>对象HashCode相不相同（内存地址）</p><p>HashCode不相同，则不重复</p><p>HashCode相同，则重复</p></blockquote><blockquote><p><strong>注:</strong></p><p>HashCode的算法可以自己修改，以达到判断是否相同的目的</p></blockquote><h5 id="更改判断标准"><a href="#更改判断标准" class="headerlink" title="更改判断标准"></a>更改判断标准</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> User user)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> id == user.id &amp;&amp; name.equals(user.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;E&gt; set =<span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br></pre></td></tr></table></figure><h5 id="增-2"><a href="#增-2" class="headerlink" title="增"></a>增</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set.add(Object element);</span><br><span class="line"><span class="comment">//添加单个元素</span></span><br><span class="line"></span><br><span class="line">set.addAll(Collection c);</span><br><span class="line"><span class="comment">//添加一个集合的元素</span></span><br></pre></td></tr></table></figure><h5 id="删-2"><a href="#删-2" class="headerlink" title="删"></a>删</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.remove(E element);</span><br></pre></td></tr></table></figure><h5 id="改-2"><a href="#改-2" class="headerlink" title="改"></a>改</h5><p>**注:**HashSet中没有改的操作</p><h5 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h5><p>**注:**HashSet中没有查的操作</p><h5 id="其他常用方法-2"><a href="#其他常用方法-2" class="headerlink" title="其他常用方法"></a>其他常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object[] set.toArray();</span><br><span class="line"><span class="comment">//将set转化为数组</span></span><br><span class="line"></span><br><span class="line">set.clear();</span><br><span class="line">set.isEmpty();</span><br><span class="line"> </span><br><span class="line"><span class="type">boolean</span> set.contains(Object element);</span><br><span class="line"><span class="type">boolean</span> set.containsAll(Collection c);</span><br></pre></td></tr></table></figure><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>​队列</p><p>​具体实现类：ArrayBlockingQueue</p><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>ArrayBlockingQueue&#x3D;Array(数组)+Blocking(阻塞,队列有限)+Queue（队列）</p><h5 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayBlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="type">int</span> size);<span class="comment">//输入容量</span></span><br></pre></td></tr></table></figure><h5 id="增-3"><a href="#增-3" class="headerlink" title="增"></a>增</h5><h6 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h6><blockquote><p>在队列的尾部添加元素，返回true。当队列满的时候会抛出IllegalStateException异常。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br></pre></td></tr></table></figure><h6 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h6><blockquote><p>在队列的尾部添加元素，如果队列已满，则会阻塞住，等待队列有空闲位置，该方法可被打断。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure><h6 id="offer方法"><a href="#offer方法" class="headerlink" title="offer方法"></a>offer方法</h6><blockquote><p>超出队列最大值，不会报错，返回false</p><ul><li>e：添加的元素</li><li>timeout：最多等待的时长</li><li>unit：时间单位</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">//添加数据成功，则返回true</span></span><br><span class="line"><span class="comment">//添加数据失败，则返回false</span></span><br></pre></td></tr></table></figure><h5 id="取"><a href="#取" class="headerlink" title="取"></a>取</h5><h6 id="poll方法"><a href="#poll方法" class="headerlink" title="poll方法"></a>poll方法</h6><blockquote><p>先进先出</p><p>获取队列中队首的元素，获取后该元素就会移除该队列</p></blockquote><ul><li>timeout：等待时长</li><li>unit：时间单位</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//立即返回</span></span><br><span class="line">E <span class="title function_">poll</span><span class="params">()</span></span><br><span class="line"><span class="comment">//如果不能立即取出，则等待一定时间</span></span><br><span class="line">E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">queue.offer(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">queue.offer(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">queue.offer(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">System.out.println(queue.poll());</span><br><span class="line">System.out.println(queue);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">张三</span><br><span class="line">[李四, 王五]</span><br></pre></td></tr></table></figure></blockquote><p>**注：**当队列里面所有数据全部取出后，继续取出queue.poll(),则返回null</p><h6 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h6><blockquote><p>获取队列中的元素，如果没有则会被阻塞住。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure><h6 id="peek方法"><a href="#peek方法" class="headerlink" title="peek方法"></a>peek方法</h6><blockquote><p>读取队列中队首的元素，不会删除该元素。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">peek</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h5 id="删-3"><a href="#删-3" class="headerlink" title="删"></a>删</h5><h6 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h6><blockquote><p>删除队列中指定元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br></pre></td></tr></table></figure><h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;<span class="comment">//查询队列中是否存在某个元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">remainingCapacity</span><span class="params">()</span>;<span class="comment">//返回队列中剩余空闲位置</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c, <span class="type">int</span> maxElements)</span>;</span><br><span class="line"><span class="comment">//将队列中的元素排到指定集合中</span></span><br><span class="line"><span class="comment">//c：目标集合</span></span><br><span class="line"><span class="comment">//maxElements：最多排几个元素</span></span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>具体实现：HashMap，Hastable</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote><p><code>HashMap</code>是一个散列表，它存储键值对（key-value pairs），每个键对应一个唯一的值。<code>HashMap</code>不保证顺序，并且允许<code>null</code>值作为键或值。</p></blockquote><h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h4 id="增-改"><a href="#增-改" class="headerlink" title="增 改"></a>增 改</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">put</span><span class="params">(K key, V value)</span>;</span><br><span class="line"><span class="comment">//获取与指定键 key 相关联的前一个值。如果不存在针对该键 key 的映射关系，那么就返回 null</span></span><br></pre></td></tr></table></figure><blockquote><p>改动value时</p><p>接下来我们探讨Key的值不可重复（当Key的值重复的时候，后面插入的对象会将之前插入的具有相同的Key值的对象覆盖掉），Value的值可重复</p></blockquote><h4 id="查-2"><a href="#查-2" class="headerlink" title="查"></a>查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">get</span><span class="params">(K key)</span>;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><blockquote><p>返回被删除的键值对的值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K <span class="title function_">remove</span><span class="params">(K key)</span>;</span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;=&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><code>containsValue</code>:判断<code>HashMap</code>是否包含指定的值，返回<code>true</code>或者<code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(V value)</span></span><br></pre></td></tr></table></figure><p><code>keySet()</code>:返回<code>HashMap</code>中所有键的<code>Set</code>视图。通过这个<code>Set</code>可以遍历<code>HashMap</code>中的所有键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p><code>values()</code>:返回<code>HashMap</code>中所有值的<code>Collection</code>视图。可以用于遍历<code>HashMap</code>中的所有值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>；</span><br></pre></td></tr></table></figure><p><code>entrySet()</code>:返回<code>HashMap</code>中所有键值对的<code>Set</code>视图，其中每个元素都是<code>Map.Entry</code>类型。可以用于同时遍历键和值</p><blockquote><p>通过遍历这个<code>Set</code>，可以同时访问<code>HashMap</code>中的键和值，这在需要对键值对进行操作（如打印、修改或删除）时非常有用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey().equals(<span class="string">&quot;key1&quot;</span>))&#123;</span><br><span class="line">                entry.setValue(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
